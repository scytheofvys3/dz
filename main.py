import this # импорт Дзен питона
print("Hello World") # =str-string строка

print(type(5)) # тип числа =int-integer - целое число
print(type(2.1)) # тип числа =float число с плавающей запятой
print(type("Stro4ka")) # тип данных =str-string строка

# concatenate - связывает, сцепляет, соединяет оператор +, но одинаковые объекты
# запятая в командах "," говорит о том, что элемент закончился и сейчас будет другой

print(78 % 33) # сколько в число 78 помещается число 33 получим остаток от этого/остаток от деления
print(78/33) # деление с плавающей запятой =float
print(78//33) # деление с ответом без запятой =int-integer
print(7 % 7) # сколько в число 7 поместится число 7, если поместилось, то это 0

print(5 ** 3) # степень

#boolean - тип данных "примитивно" да-нет, истина-ложь
print(type(True),type(False))
print(5 == 5, 5 > 2, 3 < 1, 5 != 5, 5 != 4) # == - они равны?, != - они не равны?

'''команда and= и, or= или'''

# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'СТРОГИЙ ОПЕРАТОР'
print(5 == 5 and 5 != 5)
print(10 == 10 and 6 > 3)

# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.
'НЕ СТРОГИЙ ОПЕРАТОР'
print(5 == 5 or 5 != 5)
print(5 > 6 or 6 > 7 )

# Перевод данных в другой тип. Текстовую пятерку перевел в число и также наоборот в строку. Код расшифровывается справа налево.
print(type(int("5")))
print(type(str(5)))

## DZ 1
# 1st program
print(9 ** 0.5 * 5)
# 2nd program
print(9.99 > 99.98 or 1000 != 1000.1)
# 3rd program
print(2 * 2 + 2 == 2 * (2 + 2))
# 4th program
print(int(float ('123.456')* 10 % 10))

# Динамическая типизация - это смена типа данных в переменной
# Оператор = присваивает переменной (прим. Name) тип данных, то есть переменная name ссылается на значение Urban
# Получается, что правый объект присваивает себе некую переменную(левое значение), которую в дальнейшем можно использовать
name1 = 'Urban'
print(name1, type(name1))
name1 = 5
print(name1, type(name1))
name1 = 2.2
print(name1, type(name1))

name01 = 5
name01 = 6
print(name01 + name01) # Запомнит он последний объект привязанный к одной переменной

## DZ 2
name = 'Ilya'
print(name, type(name))
age = 24
print(age,type(age))
age = age + 24
print(age,type(age))
is_student = True
print(is_student, type(is_student))

# Переменная - хранит в себе информацию к которой мы можем обращаться в дальнейшей работе
# Важно, чтобы переменная носила осмысленное название и была эксклюзивной (не была названа другой командой)
# Snake case - название переменной пишется через нижнее подчеркивание (для читаемости и быстрого понимания) - data_of_brith
# Camel case - название переменной пишется с заглавной буквы (каждое слово) - dataOfBrith
## Мне больше понравился стиль snake case, в дальнейшем иногда можно путать ноль и букву О

a, b, c = 1, 2, 3 # Множественное присваивание - присвоить сразу несколько значений в одной строке
print(c + b * a)

a =  b = c = 67 # Каскадное присваивание - то есть a = b = c, а все перечисленные переменные содержат объект int-integer 67
print(a + b + c)

d = list ('Begin') # Преобразование строки в список по символам - (пока не знаю для чего)
print(d)

list1 = [5, 3, 1] # Множественное присваивание со списками (Пока не очень понимаю для чего это)
a, b, c = list1

# DZ 3
completed_dz = 12 # Выполнено заданий
hours_spent = 1.5 # Время на одно задание
name_cource = 'Python' # Название курса
time_one_job = int (completed_dz / hours_spent) # Время на выполнение одного задания

print("Курс:", name_cource,",","Затраченное время на одно задание:", hours_spent,",","Среднее время на выполнения одного задания:", time_one_job, "ч.")

name = "IlyaNefedov"
print('Hello, ' * 2 + name) # Дублирование строки через оператор *

# Индексация строки у каждой строки есть свой порядковый индекс начинается он с нуля
# Так же можно выводить и последнюю букву начиная с -1 (последняя буква), -2 (предпоследняя буква) и так далее.
print(name [0]) # нулевой индекс принимается как первая буква и так далее
print(name [-1]) # индекс со знаком минус выводит буквы с конца
print(name [0:5]) # срез строки последний элемент не выводится, то есть получается 0 - 4 (в данном случае)
print(name [0:8:2]) # 0 начало, 8 конец, 2 шаг # выведет нам с 0 индекса по 8 (не включительно) с шагом 2
# Так же мы можем пропускать начальное и последние значение
print(name [:11]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [:5]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [0:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [4:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [::-1]) # срез с конца строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [::1]) # срез с начала строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [-1:-10:-2]) # срез с конца строки, но в начале, до 10 индекса с шагом два, обратный порядок

cc = "HelloWorld"
# Индексация строки:
#  H  e  l  l  o  W  o  r  l  d
#  0  1  2  3  4  5  6  7  8  9  (прямые индексы)
# -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 (отрицательные индексы)

print(cc[-4:])  # Результат: "orld"

# DZ 4
example = 'AnString'
print(example [0]) # Первый символ в строке
print(example [-1]) # Последний символ в строке с использованием обратного индекса
print(example [3:]) # Вторая половина строки с нечетным кол-во букв
print(example [::-1]) # Слово наоборот
print(example [::2]) # Каждый второй индекс в строке с использованием шага

##name = input('Введите свое имя: ') # команда input говорит о том, что пользователю нужно ввести данные с клавиатуры
##current_data = 2024 # год на данный момент
##data_of_brith = int (input ('Ваш год рождения: ')) #год рождения юзера, команда int, которая преобразует ВВОД в число
### тк как изначально ВВОДИМЫЕ ДАННЫЕ имеют класс str-string строка
##age = current_data - data_of_brith # год на данный момент минус год рождения юзера
##print ('Добро пожаловать,',name) # выводи приветствия и имя юзера
##print ('В этом году вам исполнилось',age, 'года/лет' ) # выводит строку сколько лет исполнилось юзеру и переменную age
#^^^^ обычная программа, которая считает возраст юзера (без месяца и дня)


print('я строка в нижнем регистре'.replace('строка','человек'))
#заменили слово строка на человек
print('я строка в нижнем регистре'.replace('строка','Человек').replace('я','В').replace(' ','-'))
#замена нескольких слов в строке
print('я строка в нижнем регистре'.replace(' ','.')) #заменили символ ПРОБЕЛ ( ) на символ ТОЧКУ
# Метод .upper() - переводит текст в Верхний регистр
# Метод .lower() - переводит текст в Нижний регистр
# Метод .replace('что заменить','на что заменить') - заменяет выбранное слово на другое
# Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
# isdigit = is(является)digit(цифрой) - является цифрой
# Метод .title() делает каждую первую букву слова заглавной, при этом все остальные буквы переводятся в нижний регистр

# Метод .split() разделяет строку на подстроки
##sep — разделитель, по которому разбивается исходная строка.
# По умолчанию или при указании None разделителями будут считаться любые пробельные символы
# (пробел, перевод строки, табуляция и другие).
##maxsplit — параметр, который определяет максимальное количество разбиений.
# По умолчанию (или если указано -1) строка разбивается полностью на все возможные подстроки.

#DZ 5
##my_string = input ('Введите произвольный текст:') # ввод текста в формате данных str
##print('Кол-во символов в строке:',len(my_string)) # функция len подсчитывает кол-во элементов
##print(my_string .upper()) # изменяем текст на верхний регистр
##print(my_string .lower()) # изменяем текст на нижний регистр
##print(my_string .replace(' ', '')) # удалям ПРОБЕЛЫ на ничего
##print(my_string [0:1]) # вывод первого символа в строка
##print(my_string [-1]) # вывод последнего символа в строке
#Здесь должен быть текст посвященный университету урбан

# СПИСКИ
# list_
food = ['apple', 'coco', 'banana', 'cherry', 2] # в квадратных скобках хранятся элементы списка
# то есть у каждого элемента есть порядковый номер он же - индекс
print(food[3]) # нумерация начинается с нуля, как и любой индекс
food [0] = 'beef'# замена нулевого индекса(то есть первого слова) на другое слово
food [2] = 2024 # замена второго индекса(то есть третьего слова) на другой элемент
# списки изменяемые, то есть их можно менять
print(food)
# функция len подсчитывает кол-во элементов, если элементы будут в списке она посчитает сколько элементов в списке

food.append(True) # добавили элемент True
# в списках могут храниться любые типы данных
# добавить в список можно любой тип данных
food.append('pear') # добавили элемент
# метод .appent(что добавить) добавляет элемент в конец списка, можно добавить только один элемент
#food.extend(['True',2,'false'])
food.extend('True')
# метод .extend(что добавить) если добавлять одно слово, то оно разбивается по символам/буквам (каждый отдельно)
food.extend(['True', 2, 'Foll'])
# если добавлять в квадратных скобках(список), то можно сразу несколько разных типов данных
# причина почему она не разбивается на отдельные символы в том, что мы в квадратных скобках уже добавляем последовательность
food.remove('cherry')
# метод .remove # удаление элемента из списка, можно удалить только один элемент

print("beef" in food) # командой in(в) можно проверять если элемент в списке
print('beeed' in food)
# данную команду можно расшифровывать как - если ли "слово (in) в списке?"
print('coco' not in food) # командой not in(не в) можно проверить отсутствие элемента в списке
print('peaar' not in food)
# данную команду можно расшифровывать как - "слово не в списке"?
print(food [-1::-1]) # так же мы можем проводить индексация со списком
print(food)

# tuple - (тайпл) - кортеж - неизменяемый список, может содержать разные типы данных, так же как и список
# тот же самый список, но не изменяемый. нельзя изменить, удалить, добавить
# так же можно хранить в кортеже список
# class "tuple" - кортеж
tuple0 = (1, 2, 3, 4) + (9, 7, 8)
tuple1 = ('string', 'apple', 1, 5, True) # разные типы данных
tuple2 = ('beef', 'classic', ['dream', 'mono', 1, 3]) # так же можно хранить в кортеже список
print(tuple0)
print(tuple1)
print(tuple2)
tuple2[2][0] = 'bag' # в кортеже можно изменять ТОЛЬКО, что уже изменяется - то есть список в квадратных скобках
print(tuple2)
tuple3 = ("dragon",) * 3 # ВАЖНО, если КОРТЕЖ содержит один элемент, то он должен заканчиваться запятой, иначе мы не получим кортеж
# так же можно умножать
print(tuple3)
print(type(tuple3))

# DZ 6
immutable_var = ('string', 'm-track', 'gaming', 1, 2, 3, True, False, ['apple', 'cherry', 'coco'])
print(immutable_var)
immutable_var [8][0] = 'alesis' # кортеж не изменяется, если в нем нет изменяемых данных (к таким относятся типы данных как список)
print(immutable_var)

mutable_list = ['glass', 'long', 'bridge', 1, 5, 10, True]
print(mutable_list)
mutable_list.append('self-mish') # добавили элемент
mutable_list.extend('delete') # добавили элемент по разбиванию на символы
mutable_list.extend(['insert' ,'end']) # если добавлять два элемента команда идентична .append
print(mutable_list)
mutable_list .remove('bridge') # удалили элемент
print(mutable_list)

# Словарь, пара, есть ключ и значение. Изменяемый тип данных .class "dict"
phone_book = {'Ilya':89524460977,'Gaben':30685006988, 'Alina':[89108845077,321], 'Spam':89005558085}
# работает это следующим образом 'КЛЮЧ' : 'ЗНАЧЕНИЕ', 'КЛЮЧ' : 'ЗНАЧЕНИЕ'
# на месте ключа не может быть измененных данных, но в значение может быть и список
print(phone_book)
# если нам нужен элемент, то мы должны с помощью [] указать ключ
# print ('HOMEP:', phone_book['Ilya'])
phone_book['Ilya'] = 89524444444 # мы можем изменять ЗНАЧЕНИЕ обращаясь к ключу
print(phone_book)
phone_book['Misha'] = 89107798734 # если мы обращаемся к несуществующему ключу и пробуем его изменить, он его создает
print(phone_book)
del phone_book['Spam'] # оператор del удаляет данные привязанные к ключу
#оператор del удаляет данные привязанные к ключу
print(phone_book)
phone_book.update( # обновляем список, то есть вводим в него новые данные
    {'Anton' : 89203219876,
     'Vova' :  89556498718}
    )
# метод .update обновляет словарь - вставляет в него новые данные
print(phone_book)
print(phone_book.get('Gaben')) # метод .get позволяется ПОЛУЧИТЬСЯ значение по ключу
print(phone_book.get('Spam')) # метод .get лучше, чем обращение, так как не создает данные, а покажет none - пусто, ничего
print(phone_book.get('Spam', 'Такого ключа не существует'))# так же мы можем поменять значение none на свое через (запятую) после ключа
print(phone_book)
# phone_book.pop('Vova') # так мы удаляем ключ со значением (удаляет один ключ со значением)
# метод .pop удаляет ключ со значением, а если мы укажем переменную, то мы как бы извлечем/перенесем ключ со значением в переменную
delete_phone_book = phone_book.pop('Vova')
print(delete_phone_book)
# list_one = [1,2,3] #,a = list_one.pop(1), print (a) ,print (list_one)# тоже самое можно проделывать со списком
print(phone_book)
print(phone_book.keys()) # метод .keys позволяет получить список ключей
print(phone_book.values()) # метод .keys позволяет получить список значений
print(phone_book.items()) # метод .item позволяет получиться ключ и значение

# Множество class "set"
# Особенность множества в том, что хранит оно только уникальные значения, то есть повторных данных быть не может
set_ = {1, 2, 3, 4, 5, 5, 1, 3, 'StringAll', (1, 2, 3, 4, 9, 1)} # может хранить как числа, так и строки, так и кортеже (при списках выдает ошибку)
# при том что кортеж может хранить в себе повторяющие файлы
set_.discard(1,) # удаление первого элемента (не путать с индексом) удаляет по одному
# метод .discard() удаляет элемент из множества
print(set_)
list_1 = [1, 2, 3, 4, 4, 2, 1] # список
list_1 = set(list_1) # список перевели в множество
print(list_1)
list_1.discard(1) # метод .discard удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то ошибки не будет
list_1.remove(2) # удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то выдаст ошибку
# метод .discard от .remove отличаются тем, что дискард не выдаст ошибку при удалении, если такого элемента не будет
print(list_1)
# метод .pop работает по такому же принципу, что в списках и кортежах
# метод .add добавляет элемент в множество (один элемент)
list_1.add(17)
list_1.add(12)
print(list_1)

# DZ 7
my_dict = {'Ilya':2000, 'Alina':1999, 'Egor':1998} # Словарь с именами и год рождения
print(my_dict)
print(my_dict.get('Egor')) # запрос данных с помощью ключа, метод .get
print(my_dict.get('Misha','Данных нет')) # запрос данных с помощью ключа, метод .get, так как данных нет он выдает none
# но после ключа через запятую можно указать, текст при отсутствии данных
my_dict['Nikita'] = 1987 # если мы обращаемся к несуществующему ключу, то он создает его
my_dict['Artem'] = 1974 # а так мы могли изменить значение по ключу
print(my_dict)
deleted_my_dict = my_dict.pop('Egor') # методом .pop мы можем удалить элемент, но если мы присвоим ему переменную, то значение сохранится в переменную
print(deleted_my_dict) # вывод в консоль удаленного элемента и сохраненного в переменную
del my_dict['Artem'] # оператор del удаляет элемент по ключу
print(my_dict)

my_set = {'beef', 'apple', 1, 2, 4, 5, 6, 2 ,4, 3, 'apple'} # множество состоящие из разных типов данных
print(my_set)
my_set.add('cherry') # метод .add добавляет элемент в множество
my_set.add(10) # метод .add добавляет элемент в множество
print(my_set)
my_set.remove('beef') # метод .remove удаляет элемент в множестве (указать сам элемент)
print(my_set)

# DZ 8
grades = [[5, 3, 3, 5, 4], [2, 2, 2, 3], [4, 5, 5, 2], [4, 4, 3], [5, 5, 5, 4, 5]]
students = {'Johnny', 'Bilbo', 'Steve', 'Khendrik', 'Aaron'}
avg_scores = {} # пустой словарь для среднего балла
names = list(students) # преобразуем множество в список
names.sort() # в алфавитном порядке методом .sort
avg_scores.update(
    {names[0]:sum(grades[0]) / len(grades[0]), names[1]:sum(grades[1]) / len(grades[1])})
avg_scores.update(
    {names[2]:sum(grades[2]) / len(grades[2]), names[3]:sum(grades[3]) / len(grades[3])})
avg_scores.update(
    {names[4]:sum(grades[4]) / len(grades[4])})
# Обновили список следующим образом
# {Имя[Индекс]:Сумма.sum (НазваниеСписка[Индекс]/Кол-во символов.len(НазваниеСписка[Индекс])}
# функция sum сумма чисел
# функция len кол-во символов
print(avg_scores)

# DZ 1 GPT
grades = {
    'Lily': {'math': [4, 3, 5], 'english': [5, 4, 4], 'history': [3, 4]},
    'James': {'math': [5, 5, 4], 'english': [3, 4, 3], 'history': [4, 5]}
}
avg_scores_by_subject = {} # пустой словарь
avg_scores_by_subject.update(
    {"lily":{'math':sum(grades['Lily']['math']) / len(grades['Lily']['math']),
             'english':sum(grades['Lily']['english']) / len(grades['Lily']['english']),
             'history':sum(grades['Lily']['history']) / len(grades['Lily']['history'])}}
)
avg_scores_by_subject.update(
    {"James":{'math':sum(grades['James']['math']) / len(grades['James']['math']),
             'english':sum(grades['James']['english']) / len(grades['James']['english']),
             'history':sum(grades['James']['history']) / len(grades['James']['history'])}}
)

print(avg_scores_by_subject)
print(grades['Lily']['english']) # выводим оценки по предмету 'english' для 'Lily' из словаря grades(слева направо читается код)

# DZ 9
print('Hi,PyCharm and Urban') # вывод текста в консоль
x = 43 # присваиваем переменной х значение 43
y = 32 # присваиваем переменной y значение 43
print(x * y) # вывод в консоль переменной x * y
print('End line') # вывод текста в консоль

name = input('Введите ваше имя: ')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# то выводится строка которая в этом блоке прописана с помощью табуляции
# двоеточие в конце служит для конца условия
# принимает только одно условие
if name == 'Илья':
    print(f'Добро пожаловать юный падаван, {name} ')
# elif это сокращение от else if - иначе если
elif name == 'Алина':
    print(f'Добро пожаловать юный падаван, {name} ')
# else - иначе. Сразу ставится двоеточие
else:
    print(f'Привет, {name}')

number = int(input('Введите число: '))
# if(если) остаток от деления на 3 равен 0, выводим Fizz
if number % 5 == 0  and number % 3 == 0:
    print('FizzBuss')
elif number % 3 == 0:
    print('Fizz')
elif number % 5 == 0:
    print('Buss')
else:
    print('Программе не нравится число')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# elif это сокращение от else if - иначе если
# else(иначе) сразу ставится двоеточие

'''if — проверяет первое условие.
elif (сокращение от else if) — проверяет следующие условия, если предыдущее условие ложно.
else — выполняет блок кода, если все предыдущие условия ложны.'''

'''Cуществует негласное правило при формировании условий: когда имеются несколько условий, самое маловероятное или самое сложное следует поместить в начало'''
# elif это сокращение от else if - иначе если
'СТРОГИЙ ОПЕРАТОР'
# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'НЕ СТРОГИЙ ОПЕРАТОР'
# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.

# DZ 10
first = int(input('Введите 3 целых числа: '))
second = int(input('Введите 3 целых числа: '))
third = int(input('Введите 3 целых числа: '))
if first == second == third: # if(если) first равняется second равняется third то выводим 3, то три значения равны
    print(3)
elif first == second or second == third or first == third: # здесь получается надо нам получиться одну истину, чтобы получить значение 2
    print(2)
else: # иначе если не одно число не равно, то получаем ноль
    print(0)

'''Ctrl + Alt + L''' # сборка кода по пеп8

# DZ 2 GPT
a = int(input('Введите одно число: '))
b = int(input('Введите одно число: '))
c = int(input('Введите одно число: '))
d = int(input('Введите одно число: '))
if a == b == c == d:
    print(4)
elif a == b == c or a == b == d or b == c == d or a == c == d:
    print(3)
elif a == b or a == c or a == d or b == c or b == d or c == d:
    print(2)
else:
    print(0)


'''while - до тех пор, пока, это значит, что до тех пор, пока условие, вводимое while, 
истинное, тело цикла продолжит выполняться, при этом количество итераций заранее не известно 
(в отличие от циклов с оператором for).'''

while True:
    number = int(input('Введите число: '))
    if number % 2 == 0:
        print('Число четное')
        break
        # break - завершает выполнение цикла полностью
        # Используется, для выхода из цикла, как только выполнено нужное условие
    else:
        print('Число нечетное')

# continue - пропускает текущую итерацию цикла и переходит к следующей
 # Используется, для перехода к следующей итерации, если выполнено нужное условие

# Пример с тройкой
# GPT Пример работы "continue"
i = 1
while i <= 5:
    if i == 1:
        i += 1  # увеличиваем i перед continue, чтобы избежать зацикливания
        continue  # Пропускаем вывод 1 и переходим к следующей итерации
    print(i)
    i += 1


while True:
    number = int(input('Введите число: '))

# Проверка на отрицательное число
    if number < 0:
        print('Число отрицательное. Введите положительное число.')
        continue # Возвращаемся к началу цикла, чтобы снова запросить ввод

    # Проверка на четность
    if number % 2 == 0:
        print('Число четное')
        break # Завершаем цикл, если число четное
    else:
        print('Число нечетное')

'''# break - завершает выполнение цикла полностью
# Используется, для выхода из цикла, как только выполнено нужное условие

# continue - пропускает текущую итерацию цикла и переходит к следующей
# Используется, для перехода к следующей итерации, если выполнено нужное условие
# Обычно ставится в начале, когда нужно сразу пропустить текущую итерацию цикла, если выполнено определенное условие
# Важно заметить, что continue можно ставить в любом месте цикла, в зависимости от логики программы
# Главное, чтобы оно выполняло свою задачу — пропускать текущую итерацию и переходить к следующей'''

# DZ 10
my_list = [42, 69, 322, 13, 0, 99, -5, 9, 8, 7, -6, 5]
my_list_index = 0 # начальный индекс для списка my_list
while my_list_index < len(my_list): # цикл идет до того момента пока индекс меньше длины списка
    if my_list[my_list_index] < 0: # если элемент списка меньше 0
        break # то цикл заканчивается, тк встретили отрицательно число
    elif my_list[my_list_index] > 0: # иначе если элемент списка больше 0
        print(my_list[my_list_index]) # вывод его в консоль
    my_list_index += 1 # увеличиваем индекс, чтобы перейти к следующему элементу списка
    # Увеличение индекса должно быть вне блоков if или elif, потому что мы хотим, чтобы индекс увеличивался в любом случае после каждого прохода цикла,
    # Независимо от того, выполнилось ли условие в if или elif.

'''В Python квадратные скобки [] — это стандартный синтаксис для индексации (обращения к элементам коллекций). 
Когда ты пишешь my_list[my_list_index], ты говоришь программе: 
"Возьми элемент списка my_list, который находится на позиции, указанной в переменной my_list_index."'''

# DZ GTP 3
numbers = [2, 7, 18, 5, 6, 12, 9, 22, 4, 15, 10]
numbers_index = 0
while numbers_index < len(numbers):
    if numbers[numbers_index] > 20:
        break
    if numbers[numbers_index] == 10:
        numbers_index += 1
        continue
    if numbers[numbers_index] % 2 == 0:
        print(numbers[numbers_index])
    numbers_index += 1
print('123')

# DZ 4 GPT
temps = [16, 22, 20, 14, 26, 18, 9, 23, 15] # температура
temps_index = 0
while temps_index < len(temps):
    if temps[temps_index] < 10:
        break
    if temps[temps_index] == 20:
        temps_index += 1
        continue
    if 15 <= temps[temps_index] <= 25:
        print(temps[temps_index])
    temps_index += 1

# for (название переменной), как правило, ее называют «i», «j» или «k»
# данные переменные будут существовать только в переделе цикла
# for(для)(переменной) in(в) "последовательность"

for i in 1, 2, 3, 4:
    print(i)
list_ = ['hello', 'world', 'party']
for i in list_:
    if i == 'party':
        list_.remove(i)
print(list_)

# range радиус можно указать цифрами, но тогда программа может выдать ошибку если мы не
# знаем сколько элементов, функция len возвращает нам длину элемента, которого мы напишем в скобках
list_ = ['hello', 'world', 'party']
for i in range(len(list_)):
    print(list_[i]) # вывод на экран каждого элемента по отдельности
    list_[i] = 'vince'
    print(list_[i]) # замена каждого элемента на другой

list_2 = [2, 4 ,8, 9, 1, 19]
sum_ = 0
for i in range(len(list_2)):
    sum_ += list_2[i]
print(sum_)

# for i in range(11): # start, end, step - если записать одно число, то оно воспринимается как конец
# функция range конец не включительный
for i in range(1, 11): # start, end, step # i - 1
    for j in range(1, 11): # j - 1
        print(f'{i} x {j} = {i*j}')
# первый цикл с переменной i создается со значением 1
# дальше внутренний цикл с переменной j со значением 1
# пока цикл for с переменной j не дойдет до 10, то цикл for с переменной i не поменяется и так по кругу

dict_ = {'a': 1, 'b': 2, 'c': 3}
for i in dict_:
    print(i, dict_[i])

dict_1 = {'a': 1, 'b': 2, 'c': 3}
for i, k in dict_1.items():
    print(i, k)

# DZ GPT
numbers = [10, 15, 20, 25, 30, 35, 40, 45, 50]
even_numbers = []
odd_numbers = []
for i in range(len(numbers)):
    # Цикл for перебирает индексы списка numbers, начиная с 0 и заканчивая (длина списка - 1).
    # Функция range(len(numbers)) создаёт последовательность чисел от 0 до len(numbers) - 1.
    # На каждой итерации переменная i принимает текущее значение из этой последовательности.
    # Таким образом, i указывает на индекс текущего элемента в списке numbers.
    # Переменная i временная и меняется на каждом новом круге цикла, пока не переберёт все индексы.
    ### Итерация - повторение
    n = numbers[i] # n — это текущее число из списка `numbers`, с которым мы сейчас работаем
    if n % 2 == 0: #  Если остаток от деления числа `n` на 2 равен 0, то оно четное
        even_numbers.append(n) # Добавляем `n` в список четных чисел
    else: # Иначе, если число не делится на 2 без остатка, оно нечетное
        odd_numbers.append(n) # Добавляем `n` в список нечетных чисел
print('Even', even_numbers)
print('Odd', odd_numbers)

numbers = [3, 10, 15, 18, 20, 21, 25, 30, 33, 35, 40, 45, 50, 60]
divisible_by_3 = []
divisible_by_5 = []
for i in range(len(numbers)):
    n = numbers[i]
    if n % 3 == 0:
        divisible_by_3.append(n)
    if n % 5 == 0:
        divisible_by_5.append(n)
print(divisible_by_3)
print(divisible_by_5)

numbers = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
even_numbers = []
greater_than_ten = []

for k in (numbers):
    # k = numbers[i]
    if k % 2 == 0:
        even_numbers.append(k)
    if k > 10:
        greater_than_ten.append(k)

print(even_numbers)
print(greater_than_ten)

numbers = [23, 45, 12, 67, 89, 34, 54, 23, 90, 123, 78, 56]
odd_numbers = [] # нечетные
even_numbers = [] # четные
for q in numbers:
    if q % 2 == 0:
        even_numbers.append(q)
    else:
        odd_numbers.append(q)
print(odd_numbers)
print(even_numbers)
print(sum(odd_numbers))
print(sum(even_numbers))

numbers = [30, 45, 60, 23, 70, 81, 90, 100, 125, 150, 170, 200]
divisible_by_5 = []
divisible_by_3_and_5 =[]
greater_than_50 =[]
for b in range(len(numbers)):
    z = numbers[b]
    if z % 5 == 0 and z % 3 == 0:
        divisible_by_3_and_5.append(z)
    if z % 5 == 0:
        divisible_by_5.append(z)
    if z > 50:
        greater_than_50.append(z)

print(divisible_by_5)
print(divisible_by_3_and_5)
print(greater_than_50)

numbers = [23, 45, 60, 70, 81, 100, 150, 170, 200, 55, 30, 9, 12]
even_numbers = [] # четные
odd_numbers = [] # нечетные
divisible_by_3_and_5 = []
numbers.sort()
for p in range(len(numbers)):
    u = numbers[p]
    if u % 3 == 0 and u % 5 == 0:
        divisible_by_3_and_5.append(u)
    if u % 2 == 0:
        even_numbers.append(u)
    else:
        odd_numbers.append(u)
print(numbers)
print(even_numbers)
print(odd_numbers)
print(divisible_by_3_and_5)
print(len(even_numbers))
print(len(odd_numbers))
print(sum(divisible_by_3_and_5))

# DZ 11
# Исходный список чисел от 1 до 15
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# Пустые списки для хранения простых и не простых чисел
primes_ = []      # Сюда добавим простые числа
not_primes = []   # Сюда добавим числа, которые не являются простыми

# Основной цикл: перебираем каждое число из списка numbers
for i in range(len(numbers)):
    is_prime = True     # Переменная-флаг: изначально считаем, что число простое
    n = numbers[i]      # Текущее число из списка, которое будем проверять

    # Вложенный цикл: проверяем, есть ли делители у числа n
    # (перебираем делители от 2 до n-1)
    for k in range(2, n):
        if n % k == 0:    # Если n делится на k без остатка, то:
            is_prime = False  # Меняем флаг на False, значит, число не простое
            break            # Прерываем вложенный цикл, так как нашли делитель

    # После проверки числа на простоту добавляем его в соответствующий список
    if is_prime and n > 1:     # Если число простое и больше 1
        primes_.append(n)      # Добавляем его в список простых чисел
    elif n > 1:                # Если число не простое и больше 1
        not_primes.append(n)   # Добавляем его в список не простых чисел

# Выводим списки простых и не простых чисел
print("Primes:", primes_)
print("Not Primes:", not_primes)

# def имя_функции (аргументы):
#     тело_функции
#     return результат
# Здесь:
# имя_функции ― название, с помощью которого можно вызывать функцию в коде;
# аргументы ― значения, которые функция принимает на вход. Это поле может быть пустым;
# тело_функции ― набор инструкций, которые выполняются при вызове;
# результат ― значения, которые функция возвращает при завершении работы.

# def (от англ. define — определить, обозначить)
# То есть, мы как бы определяем функцию. Так же, как и с переменными, по названию функции мы должны понимать ее назначение.
# Рассмотренная ниже функция – это самая простая функция, которую можно встретить - обычная.
# Но функции можно разделить на несколько видов: обычные, принимающие, возвращающие и анонимные.
# Обычная функция
def say_hello():
    print('Hello')

say_hello()

def say_hello(name):
    print('Hello', name)

say_hello(name)

# Принимающая функция
# Поскольку функция принимающая (какое-то значение), у нее есть параметр, в момент вызова функции мы обязательно должны передать этот параметр ей
def say_hello(name): # def - определить say_hello (аргумент)
    print('Hello,', name)

say_hello('Ilya')
say_hello('Alina')
say_hello('Gaben')

import random # библиотека рандом

# .randint(3, 20) метод randint генерирует случайное число от - до
# .choice(объект) метод choice генерирует случайное число из объекта

# Возвращающая функция
# Оператор return используется в функциях для возвращения данных после выполнения работы самой функции.
def lottery(): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win # Возврат win
# После команды return функция прекращает выполнять дальнейшие команды.
# Давайте попробуем вызвать нашу функцию. В ответе ничего не видим.


print(lottery()+lottery())

# Когда мы пишем просто lottery(), функция выполняется, выбирает случайное значение, но затем сразу прекращает работу и возвращает значение,
# которое просто "зависает" в памяти, так как никуда не передано. Если мы хотим увидеть это значение,
# нам нужно вывести его на экран (через print) или сохранить в переменную.
#
# Оба варианта — с print и с присвоением переменной — имеют свои особенности и подойдут для разных ситуаций:
#
# print(lottery()): Этот способ сразу выводит результат на экран, что полезно для быстрой проверки, например, чтобы увидеть результат в консоли.
#
# win = lottery(): Этот вариант сохраняет значение, и мы можем использовать его в дальнейшем коде, повторно к нему обращаться, или, как в примере,
# складывать результаты нескольких запусков функции.

# Но на самом деле возвращающие функции на месте своего вызова оставляют после себя какое-то значение.
# Мы можем поступить так, создать переменную и сохранить в нее вызов функции.
win = lottery() + lottery()
print(win)
print('----')

def lottery(mon, thue): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win1, win2 # Возврат win
win1, win2 = lottery('mon', 'thue')
print(win1, win2)
print('----')

# Если мы не знаем сколько параметров будет принимать функция, мы можем написать, например, «*args» для обычных параметров и «**kwargs» для именованных.
def lottery(*args, **kwargs): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    print(*args)
    return win1, win2 # Возврат win
win1, win2 = lottery(1, 2, 3, 4, 5, 6, 7 ,8 ,9 ,10)
print(win1, win2)
print('----')

# Параметры по умолчанию
# Но в случае с нашей функцией нам необязательно передавать параметры, если мы запустим программу, то увидим,
# что компьютер вывел «2» и «True» (Рис.21). Потому что тут были заданы параметры по умолчанию.
def test(a = 2, b = True):
    print(a, b)

test(False, 22)
test([1, 3])
# В ответе мы видим наш список и все то же «True». То есть наш список встал на место параметра «а» и распаковался, как один объект.
# Чтобы распаковать его так, чтобы каждый элемент встал на соответствующее какому-то параметру место, нам нужно поставить звездочку перед списком.
# Чтобы распаковать словарь, нужно поставить две звездочки.
test(*[1, 3])

# DZ 11
def get_matrix(n, m, value): # определяем функцию get_matrix с тремя параметрами
    matrix = [] # создаем пустой список для хранения матрицы
    for i in range(n): # цикл создает n строк в матрице
        matrix.append([]) # добавляем пустой список как новую строку
        for k in range(m): # добавляет m элементов в каждую строку
            matrix[i].append([value]) # вставляем значение value в текущую строку i
    return matrix # возврат данных в список
result1 = get_matrix(2, 2, 10) #
result2 = get_matrix(3, 5, 42) #
result3 = get_matrix(4, 2, 13) #
print(result1)
print(result2)
print(result3)

# DZ 12
# Сначала генерируем случайное число от 3 до 20
one_stone = random.randint(3, 20)
# Печатаем это случайное число, чтобы увидеть, что получилось
print(one_stone)
print('-------')
# Переменная для хранения результата
result = ''
# Два вложенных цикла: первый перебирает все значения от 1 до (one_stone-1),
# второй — от (i+1) до one_stone, чтобы не повторять одинаковые пары
for i in range(1, one_stone - 1):
    for j in range(i + 1, one_stone):  # j начинается с i+1, чтобы не повторять (i, i)
        sum_j_i = i + j  # Считаем сумму текущей пары (i + j)
        # Проверяем, делится ли число one_stone на эту сумму
        if one_stone % sum_j_i == 0:
            result += str(i) + str(j) + ' '  # Если делится, добавляем пару в результат

# Печатаем все найденные пары в строковом виде, убираем лишний пробел в конце
print(result.strip()) # strip(), чтобы удалить пробелы в конце строки

'''Существует несколько видов пространства имен:
Локальное пространство имен
Глобальное пространство имен
Встроенное пространство имен'''

'''Встроенное пространство имен включает в себя имена каких-либо встроенных функций. 
Локальное представляет собой имена, которые мы используем внутри каких-либо функций, которые мы используем и создаем самостоятельно. 
Глобальное пространство имен включает в себя все, что есть в нашей программе, исключая лишь локальное пространство.
в Python переменные, определённые вне функций, автоматически доступны внутри функций, если они только читаются, а не изменяются'''


# Глобальное пространство
z = 5
x = 10


def printer():
    # То что, находится в функции - называется локальным пространством имен
    # Часть, которая находится внутри функции, и является локальным пространством имен
    # Переменные «c» и «d» существуют до тех пор, пока функция не завершит свою работу
    ### Если нам нужно использовать глобальную переменную в функции то пишем global
    global z, x
    c = 110
    d = 220
    z = 'Str'
    x = 'Str 2'
    # В свою очередь есть такая особенность, что к глобальному пространству имен мы можем обращаться напрямую из локального
    # Сделаем для себя пояснение, что «c» и «d» у нас local, а «z» и «x» это global
    print(c, d, 'local')
    print(z, x, 'global')
 # При запуске программы мы видим, что теперь даже после завершения функции используются значения, присвоенные переменным внутри нее.
 # Таким образом во время вызова функции мы переопределили значения переменных «a» и «b» из глобального пространства имен.

printer()
print(z, x)

# DZ 13
calls = 0 # переменная со значением 0
def count_call(): # определяем count_call с пустым аргументом
    global calls # используем глобальную переменную, которая сохранена вне функции
    calls += 1 # прибавляем и сохраняем значение в переменную call
    return calls # возвращаем измененное значение в переменную calls
def string_info(string): # определяем string_info с принимающим аргументом
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    tiple1_info_str = (len(string), string.upper(), string.lower()) # создаем кортеж, подсчитываем кол-во элементов в string(принимающем аргументе)
    print(tiple1_info_str) # выводим в консоль кортеж

def is_contains(string, list_to_search): # определяем is_contains с двумя принимающими аргументами
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    string = string.lower() # создаем переменную в которой аргумент переводится в нижний регистр, так как переменные взаимозаменяемые даем такое же название
    new_list_to_search = [z.lower() for z in list_to_search] # Интересная строка. Создаем новый список, в котором элементы из списка list_to_search
                                                             # Преобразуются в нижний регистр
                                                             # Цикл
                                                             # Для каждого элемента в списке list_to_search переменная z временно принимает
                                                             # значение этого элемента, и к нему применяется метод lower(), чтобы привести строку к нижнему регистру.

    if string in new_list_to_search: # если аргумент есть в списке
        print(True) # то выводим в консоль значение True
    else: # иначе
        print(False) # выводим False

string_info('Capybara')
string_info('Armageddon')
is_contains('Urban', ['ban', 'BaNaN', 'urBAN']) # Urban ~ urBAN
is_contains('cycle', ['recycling', 'cyclic']) # No matches
print(calls)

def print_param(a = 1, b = 2, c = 3): # параметры по умолчанию, то есть если мы вызываем функция и не задаем ей параметры, он берет те, что написаны в аргументах
    print(a,b ,c)

print_param(12,3, 4) # так же мы можем переопределять параметры
print_param(c ='String') # так же мы можем указать, что хотим изменить конкретный параметр, при этом если не указывать другие параметры, то они будут взяты из параметров по умолчанию
print_param(c = 3, a = "StringSSS", b = True) # так же мы можем давать параметры в разнобой и другие типы данных

def print_param1(*, a ,b ,c):# Существует также способ конкретно указать, что параметр будет именованным. Нужно поставить знак «*» перед этим параметром.
    print(a, b ,c)
print_param1(a = 1,b = 3,c = 4)

def func_with_params(a, b = 2, c = 11):
    print(a + b + c)

func_with_params(3) # так же если в функции первое значение не по умолчанию, а следующие по умолчанию, то мы можем вызвать функцию и передать ей первое значение, а второе подставится само
func_with_params(3, 10) # но мы так же можем переопределять и второе значение
func_with_params(3)
func_with_params(3)

def func_with_params1(a, b = 2, c = []): # Значения параметров создаются не в момент, когда мы вызываем функцию, а создаются при её определении.
    c.append(a)
    print(c)
# Если запустим, то увидим, что эти значения, которые мы передаем, добавляются не в новый список, а в уже существующий
# Этот список был создан в момент определения функции func_with_params, и каждый вызов просто добавляем, в уже существующий список, новый элемент.
func_with_params1(3)
func_with_params1(3)
func_with_params1(3)
# Если нам необходимо избежать такого, например, работать в моменте, мы можем в “с” указать значение по умолчанию “None” и в функции проверить, что если “с”- “None”,
# Тогда мы говорим, что “с” будет списком, и в этот список добавим “а”, потом выведем этот список. Запускаем. В таких случаях у нас список “с” будет переопределяться.
# Если мы будем менять объекты, результат тоже будет, соответственно разным.
def func_with_params2(a, b = 2, c = None):
    if c is None: # если(if) С являет(is) None(ничего)
        c = []         # Если c равно None, создается пустой список для С
        c.append(a)    # Затем добавляется значение a в список С
    print(c)           # Печатается список С

        # Проверка if c is None:
    # Когда функция вызывается без аргумента С, параметр С будет None.
    # Проверка if c is None позволяет определить, был ли передан аргумент для С. Если С не передавали, то С равен None.
    # Если С — None, то переменной c присваивается пустой список [].

func_with_params2(2)
func_with_params2(3)
func_with_params2(4)

# DZ 14
def send_email(message, recipient, *, sender = "university.help@gmail.com"):
    ### Проверяем, что оба адреса имеют знак "@" и заканчиваются на ".com", ".ru" или ".net"
    if ('@' not in recipient or not recipient.endswith(('.com', '.ru', '.net')) or
            '@' not in sender or not sender.endswith(('.com','.ru','.net'))):
    # если(if) "элемент`а" нет(not) в(in) recipient или(or) нет(not) recipient.endswith(чего нет)
    # если у нас в if несколько условий, то они пишутся в скобках
    # метод .endswith проверяет - заканчивается ли строка указанным суффиксом, и возвращает True, если это так, или False, если нет
    ## Метод .endswith() принимает: Либо один строковый суффикс, например: string.endswith(".com").
    ## Либо кортеж из нескольких суффиксов, например: string.endswith((".com", ".ru", ".net"))
    ### Если хотя бы одно из условий истинно (то есть не выполнено), то выводим сообщение
        print(f'Невозможно отправить письмо с адреса {sender} на адрес {recipient}') # выводим
    elif sender == recipient: # иначе если sender ==(равен) recient то
        print('Нельзя отправить письмо самому себе') # выводим
    elif sender == "university.help@gmail.com": # Проверяем, используется ли адрес отправителя по умолчанию
        print(f'Письмо успешно отправлено с адреса {sender} на адрес {recipient}') # выводим
    else: # иначе ни одно из условий не выполнено
        print(f'НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса {sender} на адрес {recipient}') # выводим

send_email('Это сообщение для проверки связи', 'vasyok1337@gmail.com')
send_email('Вы видите это сообщение как лучший студент курса!', 'urban.fan@mail.ru', sender='urban.info@gmail.com')
send_email('Пожалуйста, исправьте задание', 'urban.student@mail.ru', sender='urban.teacher@mail.uk')
send_email('Напоминаю самому себе о вебинаре', 'urban.teacher@mail.ru', sender='urban.teacher@mail.ru')

# Одна “звездочка” используется для распаковки и запаковки именно позиционных параметров, которые содержат один элемент: списки, кортежи, множества и т.д.;
# Две “звездочки” используются для запаковки и распаковки именованных параметров. В Python такая коллекция одна - словари. В них элементы хранятся парами.
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем
def params3(*params): # кортеж
    print(params)

params3(1, 3 ,5, 2, 3)

def params1(a, b, c, d, e):
    print(a, b ,c ,d, e)

list1 = [1, 2, 3, 4, 5]
params1(*list1) # распаковка списка

def params2(**params): # словарь
    print(params)
params2(a= 2, b= 2) # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

# DZ 15
def print_params(a = 1, b = 'строка', c = True): # Функция с тремя параметрами по умолчанию
    print(a, b ,c) # вывод параметром

print_params(35) # вызов функции с параметром, так как он один, следующие подхватываются, которые были по умолчанию
print_params(4, 'test') # вызов функции с двумя параметром, так как их два, следующие подхватываются, которые были по умолчанию
print_params(8, None, False) # вызов функций с тремя параметрами, которые мы переопределили
print_params()

print_params(b = 25) # вызов функции с переопределением определенного параметра
print_params(c = [1, 2, 3]) # вызов функции с переопределением определенного параметра (в данном случае) создание списка в параметре C

values_list = [100, 'OneZero', True] # список
values_dict = {'a':200, 'b':'ZeroOne', 'c':None} # словарь ключ:значение

print_params(*values_list) # вызов функции с распаковкой списка
print_params(**values_dict) # вызов функции с распаковкой словаря(ключ это параметр в функции) важно, чтобы их было одинаковое кол-во
values_list_2 = [54.32, 'Строка' ] # Список
print_params(*values_list_2, 42) # вызов функции с распаковкой списка и замена параметра C (что пишет pyharm ошибочно) так как в списке уже два параметра, то мы ввели третий
'----------------------------------------------------------------------------------------------------------------------'
def test_func(*params): # функция где в аргументе одна звездочка, принимает неопределенное кол-во аргументов, создает кортеж
    print('Тип',type(params))
    print("Аргумент", params)

test_func()
test_func(1, 3, 5, 4, 6)

def summator(txt, *values):
    s = 0
    for i in values:
        s += i
    return f'{txt}{s}'

print(summator('Сумма чисел:', 2, 3, 5))

def info(**values): # # функция где в аргументе две звездочки, принимает неопределенное кол-во аргументов, создает словарь
    print('Тип', type(values))
    print("Аргумент", values)
    for key, value in values.items():
        print(key, value)
info(name='Ilya', cource='Python') # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

def info(value ,*types, name_author = 'Ilysha', **values): # # функция где в аргументе две звездочки, принимает неопределенное кол-во аргументов, создает словарь
    # всегда в аргументе функции сначала идет одна звездочка, потом две
    print('Тип', type(values))
    print("Аргумент", values)
    for key, value in values.items():
        print(key, value)
    print(types)
info('Пример использования аргументов всех типов', 2, 3, 5, 4, name='Ilya', cource='Python') # при создании словаря в вызове функции, в ключе необходимо называть именованные параметры
# Для того чтобы добавить ключ и пару через функция надо применять не двоеточие, а равно как будто что-то присваиваем

def my_sum(n, *args, txt = 'Сумма числе'):
    s = 0
    for i in range(len(args)):
        s += args[i] ** n
    print(f'{txt}:{s}')

my_sum(1, 1, 2, 3, 4, 5)
my_sum(2, 2, 3, 4, 5,txt='Сумма квадратов' )

# DZ 16
def single_root_words(root_word, *other_words): # определяем функцию с двумя аргументами (первый позиционный и второй *кортеж)
    same_words = [] # создание пустого списка
    root_word = root_word.lower() # объявляем, что root.world равен root.world.lower() преобразует аргумент в нижний регистр (название такое же так как переменные взаимозаменяемые)
    for i in other_words: # цикл перебора в котором переменная i временно принимает значение из списка
        if root_word in i.lower() or i.lower() in root_word: # проверка. если(if) root_word в(in) i.lower()
            # получается что мы проверяем есть ли слово root_word в индексе i, который при проверке преобразует слово в нижний регистр, но при в добавление в список сохранит изначальный регистр
            # так же проверяем и обратно
            same_words.append(i) # если есть совпадение, то добавляем слово хранящиеся в переменной i в список
    return same_words # возвращаем значение в список

result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')
print(result1)
print(result2)

# Рекурсия — это цепочка вызовов функции сама собой, где каждое новое значение строится на основе предыдущего,
# пока не будет достигнут базовый случай.
def summa(n):
    # Определяем функцию summa, которая принимает один аргумент n.
    # Эта функция будет использовать рекурсию для вычисления суммы всех чисел от 1 до n включительно.
    if n == 1:  # Базовый случай
        # Если n равно 1, то мы достигли базового случая.
        # Базовый случай нужен для остановки рекурсии.
        # Здесь функция просто возвращает 1, потому что сумма от 1 до 1 — это 1.
        return 1
    else:  # Рекурсивный случай
        # Если n не равно 1, то мы выполняем рекурсивный вызов.
        # Сначала функция возвращает n (текущую величину), добавляя к результату вызова summa(n - 1).
        # summa(n - 1) вычисляет сумму чисел от 1 до n-1.
        return n + summa(n - 1)

# После определения функции вызовем её для демонстрации:
print(summa(2))
# Функция summa(2) выполнит следующее:
# 1. Проверит: n == 1? Нет, перейдёт в else.
# 2. Вернёт 2 + summa(1).
# 3. В summa(1) выполнится базовый случай, и вернётся 1.
# 4. Сложит 2 + 1, результат: 3.
# И напечатает результат (3).

# DZ 17
def get_multiplied_digits(number): # определяем функцию с одним аргументом
    str_number = str(number) # Преобразуем аргумент в строку
    first = int(str_number[0:1]) # сохраняем первое число в переменную first из переменyой str_number, предварительно перевели ее в int
    if len(str_number) > 1: # если длина строки больше 1, то возвращаем число умноженную на функцию со срезом
        return first * get_multiplied_digits(int(str_number[1:]))
    # Рекурсивный случай: вызываем функцию для оставшейся части числа (все цифры, кроме первой),
    # а результат умножаем на `first`.
    # Таким образом, постепенно умножаем первую цифру на произведение остальных цифр.
    elif len(str_number) == 1: # базовый случай число строки равно 1, то возвращаем first
    # Базовый случай рекурсии: если осталась только одна цифра, возвращаем её.
        return first

resultget = get_multiplied_digits(40203)
print(resultget)

# DZ GPT
def sum_of_digits(n):
    if n < 10:  # Базовый случай: число состоит из одной цифры
        return n
    else:  # Рекурсивный случай
        last_digit = n % 10  # Последняя цифра
        remaining_digits = n // 10  # Оставшиеся цифры
        return last_digit + sum_of_digits(remaining_digits)

print(sum_of_digits(45678))

def factorial(n):
    if n < 1:
        return 'Введите число большое одного'
    # Базовый случай: если n равно 1, факториал равен 1
    elif n == 1:
        return 1
    else:
        # Рекурсивный случай: n умножается на факториал (n-1)
        return n * factorial(n - 1)

# Пример вызова функции
print(factorial(4))
print(f'Факториал для 5 равен: {factorial(5)}')  #

'''Существует перечень функций, которые встречаются при попытке преобразовать один тип данных к другому:
#int() - целое число int(input()) # вводимый текст юзера преобразуется ва число
#float() - число с плавающей запятой
#bool() - логические значения
#str() - строки
#list() - список
#tuple() - кортеж
#dict() - словарь
#set() - множество'''

salary = [2300, 1800.80, 5000, 1234.02, 7500.12]
print(round(sum(salary) / len(salary), 2),'- средняя зарплата в компании') # функция sum() - находит сумму всех значений
                                                                 # функция len() - возвращает длину передаваемой последовательности
                                                                 # функция round() - работа с числами после точки,
                                                                 # возвращает число с определенным количеством цифр после точки
print(round(max(salary),2),'- максимальная зарплата в компании')          # функция max() - находит максимальное значение/элемент в переданной последовательности
print(round(min(salary),2),'- минимальная зарплата зарплата в компании')  # функция min() - находит минимальное значение/элемент в переданной последовательности

name_salary = ['Илья', 'Алина', 'Миша', 'Юля', 'Артем']

# zip - функция, которая позволяет объединять элементы из нескольких итерируемых объектов в один итерируемый объект
### zipped_name_salary = zip(name_salary, salary) ###
### print(zipped_name_salary) # если попытаемся вызвать саму переменную, то получим адрес объекта ###
### для того чтобы работать дальше с этой переменной, нам надо указать с чем мы хотим работать ###
### print(list(zipped_name_salary)) # в данном примере указываю, что я хочу работать со списком ###
### print(dict(zipped_name_salary)) # в данном примере указываю, что я хочу работать со словарем ###
zipped_name_salary = dict(zip(name_salary, salary)) # все это дело можно сразу обернуть словарем или другим итерируемом объектом
print(zipped_name_salary['Алина'], '- зарплата Алины') # вызываем переменную, которая уже является словарем.
# используем ключ, чтобы получиться значение

a = [True, False, False]
# Функция any() проверяет объект, его содержимое, то есть пробегает по элементам.
# При условии, что хотя бы один из элементов внутри объекта будет True, функция вернёт нам True,
# в противном случае вернёт False.
'''any - любой'''
print(any(a))
a = [False, False, False]
print(any(a))
# Если смотреть на числа, например, с точки зрения логических значений, то любые числа, кроме 0, будут давать True.
a = [1, 0, 0]
print(any(a))
# Если будут все нули, то и в ответе получим False
a = [0, 0, 0]
print(any(a))
# На строки мы смотрим с точки зрения наличия в ней символов. Если строка пустая, тогда False
# При наличии в строке хотя бы одного элемента, получим True
b = ''
print(any(b))
b = 'slovo'
print(any(b))
# функции all(), если все элементы True получаем True. Если хотя бы один элемент False - получаем False.
'''all - все'''
# Если хотя бы один элемент False - получаем False
a = [1, 1, 0]
print(all(a))
# Если все элементы True получаем True
a = [1, 1, 1]
print(all(a))
'''Интроспекция — это способность какого-либо объекта получить информацию об атрибутах и методах в процесс выполнения программы.'''
# Функция dir(). Эта функция позволяет получить информацию об атрибутах объекта
# Функция dir(), вызванная без аргумента, возвращает список имен в текущей локальной области,
# а вызванная с аргументом попытается вернуть список допустимых атрибутов для указанного объекта.
'''dir - направление(скорее всего такой перевод)'''
print(dir(a))

# Метод isinstance() используется для проверки принадлежности объекта к определенному классу или типу данных.
# Он принимает два аргумента: объект, который нужно проверить, и класс или тип данных,
# к которому нужно проверить принадлежность.
## isinstance - (объект, (тип данных))
'''isinstance - относится экземпляр, этот экземпляр '''
print(isinstance(b, str)) # выводим в консоль относится ли переменная b к классу str-строка
# true - da, false - no
## Аналогичного результата можно добиться, если проверить через type равняется
print(type(b) == str) # тип переменной b равняется к классу str-строка
a = [1, 2, 3]
b = [1, 2, 3]
# Оператор «==» сравнивает значения объектов:
print(a == b) # равняется ли a и b
# Однако оператор «is»(является) проверяет идентичность объектов
print(a is b)
# Функция id() возвращает уникальный идентификатор для указанного объекта, то есть его адрес в памяти
'''id - идентификатор'''
print(id(a))
print(id(b))
c = b
print(b)
print(c)
print(id(b))
print(id(c))
# Однако оператор «is»(является) проверяет идентичность объектов
print(c is b)
# функцией Help() - если вы, допустим, забыли или нуждаетесь в помощи.
'''help - помощь'''
print(help(print))
# pass в Python — это особый оператор заглушки, который не выполняет никаких действий.
# Он находит свое применение в тех местах, где синтаксис языка требует наличие блока кода,
# но вы ещё не готовы прописывать его логику.'''
'''pass - пасс, пас, пропуск'''
def herlper1():
    '''Тут должно быть объяснение'''
    pass
'''В исходном коде Python строки документации заключаются в тройные кавычки и пишутся сразу под заголовком объекта.'''
# Извлекать строки документации можно двумя способами:
# Через встроенный для каждого объекта атрибут-переменную __doc__.
# С помощью встроенной в Python функции help, которая запускает интерактивную справочную систему.
print(herlper1.__doc__)
print(help(herlper1))

# Максимум в списке
def find_max(list_):
    max_ = list_[0]
    for i in list_:
        if i > max_:
            max_ = i
    return max_

print(find_max([20, 52, 12, 101, 15, -1, -88, 100]))

# Подсчёт четных чисел в списке
def count_even(list_):
    counter = 0
    list_kolvo =[]
    for i in list_:
        if i == 0:
            continue
        elif i % 2 == 0:
            counter += 1
            list_kolvo.append(i)
    print(list_kolvo)
    return counter

print(count_even([2, 2, 3, 4, 2, 1, 0]))

# Уникальный список
def unique(list_):
    new_list = []
    for i in list_:
        if i not in new_list: # если(if) не(not) в(in) списке(new_list)
            new_list.append(i)# то переменную i добавляем в список
    return new_list

print(unique([1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8]))

# DZ GPT
# Минимум в списке
def find_min(list_):
    min_ = list_[0]
    for i in list_:
        if i < min_:
            min_ = i
    return min_

print(find_min([20, 52, 12, 101, 15, -1, -88, 100]))

#Подсчёт нечётных чисел
def count_odd(list_):
    counter = 0
    for i in list_:
        if i == 0:
            continue
        if i % 2 != 0:
            counter += 1
    return counter

print(count_odd([2, 2, 3, 4, 2, 1, 0]))

# Уникальные числа (но в отсортированном порядке)
def unique_sorted(list_):
    new_unique = []
    for i in list_:
        if i not in new_unique:
            new_unique.append(i)
    new_unique.sort()
    return new_unique

print(unique_sorted([1, 5, 3, 1, 7, 2, 4, 5, 3, 2]))

#Сумма положительных чисел
def sum_positive(list_):
    sum_positive = 0
    for i in list_:
        if i > 0:
            sum_positive += i
    return sum_positive


print(sum_positive([-5, 10, 0, -3, 8, -2]))

#Числа больше среднего значения
def above_average(list_):
    new_above_average =[]
    list_1 = sum(list_)
    average = list_1 / len(list_)
    for i in list_:
        if i > average:
            new_above_average.append(i)
    return new_above_average

print(above_average([1, 2, 3, 4, 5, 6]))

#Удалить все отрицательные числа
def remove_negatives(list_):
    no_negatives = []
    for i in list_:
        if i >= 0:
            no_negatives.append(i)
    return no_negatives

print(remove_negatives([-5, 10, 0, -3, 8, -2]))

# Найти индексы чётных чисел
'''Не смог сам решить'''
def even_indices(list_):
    indices_ = []
    for i in range(len(list_)):  # Перебираем индексы списка
        if list_[i] % 2 == 0:  # Проверяем, чётное ли число на текущем индексе
            indices_.append(i)  # Добавляем индекс в результирующий список
    return indices_

print(even_indices([1, 2, 3, 4, 5, 6]))

#Умножить все элементы списка на заданное число
def multiply_list(list_, factor):
    multiply =[]
    for i in list_:
        k = factor * i
        multiply.append(k)
    return multiply

print(multiply_list([1, 2, 3], 3))

#Найти все элементы, которые встречаются более одного раза
'''Не смог сам решить'''
def find_duplicates(list_):
    duplicates_list = []
    seen = set()  # Для отслеживания уже встреченных элементов
    for i in list_:
        if i in seen and i not in duplicates_list:  # Если элемент уже был, но еще не добавлен в результат
            duplicates_list.append(i)
        else:
            seen.add(i)  # Запоминаем, что элемент встретился
    return duplicates_list

print(find_duplicates([1, 2, 3, 4, 5, 2, 4, 6, 7, 4, 8]))

#Перевёрнутый список
def reverse_list(list_):
    revers = []
    for i in list_:
        revers.append(i)
    revers = sorted(revers, reverse = True) # функция сортет
    return revers

#Синтаксис функции sorted():
# sorted(iterable, key=None, reverse=False)
# где:
## iterable: обязательный параметр, представляющий итерируемый объект или встроенную последовательность,
# элементы которого требуется отсортировать.
## key: необязательный параметр, представляющий функцию, которая определяет ключ сортировки.
# По умолчанию None, что означает сортировку по значениям элементов.
## reverse: необязательный параметр, определяющий порядок сортировки.
# Если - reverse=True, то сортировка будет производиться в обратном порядке (от большего к меньшему),
# а если reverse=False (по умолчанию), то сортировка будет производиться в прямом порядке (от меньшего к большему).

print(reverse_list([1, 2, 3, 4, 5]))

print(not [])
print(not [1, 2, 3])

# DZ 18
data_structure = [
    [1, 2, 3],
    {'a': 4, 'b': 5},
    (6, {'cube': 7, 'drum': 8}),
    "Hello",
    ((), [{(2, 'Urban', ('Urban2', 35))}])
]
def calculated_structure(data): # создаем функцию с позиционным аргументом
    total_sum = 0
    if isinstance(data, (int, float)): # если этот экземпляр(isinstance, объект, (тип данных, если их несколько-то в скобки)-True-Истина
        total_sum += data # то в переменную тоталсум прибавляем это значение и сохраняем
    elif isinstance(data, str): # иначе если этот экземпляр(isinstance, объект, строка)- True-Истина
        total_sum += len(data) # то в переменную тоталсум прибавляем и сохраняем длину строки
    elif isinstance(data,(list, set, tuple)): # иначе если этот экземпляр(isinstance, объект, (тип данных, тип данных) True-Истина
        for element in data: # цикл для elementa в data
            total_sum += calculated_structure(element) # рекурсивный вызов функции (в начале где иф)
    elif isinstance(data, dict): # иначе если этот экземпляр(isinstance, объект, (тип данных, тип данных)
        for key, value in data.items(): # цикл для словаря. так как в словаре два аргумента, то и временных переменной тоже две
                                        # метод .item позволяет получить ключ и значение
            total_sum += calculated_structure(key) # рекурсивный вызов функции для ключа (в начале где иф)
            total_sum += calculated_structure(value) # рекурсивный вызов функции для значения (в начале где иф)
    return total_sum # возвращаем в ответ total_sum

result = calculated_structure(data_structure) # переменная в которой функция и ее аргумент
print(result)
'''ЛОГИКА NOT(не)'''
mem = 'slovo'
if 's' in mem:
    print('s есть')
    # если буква С в слове
    # есть,правда
if 'b' in mem:
    print('s есть')
    # если буква Б в слове
    # нет, ложь
if 'k' not in mem:
    print('нет элемента k')
    # если буквы К нет в слове
    # нет, правда
if 's' not in mem:
    print('нет элемента k')
    # если буквы С нет в слове
    # есть, ложь

num = -5
if not num >= 0:
    print('число меньше или равно нулю,то оно отрицательное')
    # если число не меньше, равно нулю
if num >= 0:
    print('число больше нуля')
    # если число больше, равно нул.

##### module4
# import module4_1 as m4_1 # импортируем модуль4_1 as(как) название, которе будет использоваться в будущем, при обращенье к модулю;-1
# # чтобы использовать функции, класса, переменные без префикса module4_1/m4_1
# from module4_1 import say_hello as sh #from(из) (объект) import (что импортируем/вытаскиваем) так же можно дать сокращенное название
#                           # после импорта можно указать *, что укажет на то, что мы хотим импортировать все
# '''В начале выполнения программы мы видим сообщение «Привет», потому что интерпретатор сначала импортирует второй модуль.
# Перед тем как завершить импорт, он считывает всю информацию из модуля, обрабатывает создание функций и переменных, и,
# ###конечно же, выполняет команду «#print»###. Это поведение сохраняется независимо от способа импорта:
# даже если мы импортируем только один элемент, например, переменную «a» из «module2»,
# интерпретатор всё равно выполнит весь код модуля при запуске. Мы по-прежнему видим сообщение «Привет»,
# поскольку соответствующая функция была выполнена.'''
# print(dir(m4_1)) # # Функция dir(). Эта функция позволяет получить информацию об атрибутах объекта
#
# print('Привет, здесь мы изучаем Модули и Пакеты, в данном уроке ты находишься на 4 модуле')
#
# # print(m4_1.a) # обращаемся к модулю4_1 через точку вызываем функцию или переменную из него
# # m4_1.say_hello()
# # say_hello()
#
# print(m4_1.__name__)

##### module4_1
# def say_hello():
#     print('Привет я из функции в 4 модуле')
#     return 'Ты использовал функцию из файла модуль4_1'
#
# def main():
#     a = 50
#     b = 100
#     print('Эээ')
#     print('123')
#
# if __name__ == '__main__':
#     main()
# #Когда файл запускается как основная программа, его __name__ становится '__main__'.
# #Когда файл импортируется как модуль, его __name__ будет содержать имя файла без расширения .py (например, 'myfile').
# #__name__ — это переменная, которая всегда содержит имя модуля (или '__main__', если это основной файл).
# #__main__ — это просто строка, которая означает, что файл был запущен как основной скрипт.
# ### ИТОГ ###
# #__name__ хранит имя текущего модуля. Когда файл запускается напрямую, его __name__ равно '__main__'.
# #__main__ — это специальное значение, которое используется для проверки, был ли файл запущен напрямую или импортирован.
# print(__name__)

#from modules import module4_1
##(from)из modules(тут указана папка) (import)импорт файл - здесь импорт всего файла
##(from)из modules(тут указана папка).файл (import)импорт (что импортируем(название функции и тд))
# from modules.module4_1 import say_hello as sh

# DZ 19
from true_math import divide as tmd # из(from) модуля import (что импортируем) как(as) название к которому будем обращаться
from fake_math import divide as fmd # из(from) модуля import (что импортируем) как(as) название к которому будем обращаться

result1 = fmd(69, 3)
result2 = fmd(3, 0)
result3 = tmd(49, 7)
result4 = tmd(15, 0)

print(result1)
print(result2)
print(result3)
print(result4)

#CODEWARS 1
def likes(names):
    if not names:  # если не names, если names пуста
        return f"no one likes this"  # то возвращаем no one likes this
    elif len(
            names) == 1:  # если длина списка равняется 1, когда мы используем команду len для списка она показывает кол-во элементов в списке,
                          # а при указании индекса кол-во символов в элементе
        return f"{names[0]} likes this"  # выводим names с индексом 0, то есть первое имя, так как подсчет начинается с нуля, префикс f
    elif len(
            names) == 2:  # если длина списка равняется 2, когда мы используем команду len для списка она показывает кол-во элементов в списке
        return f"{names[0]} and {names[1]} like this"
    elif len(names) == 3:
        return names[0] + ', ' + names[1] + ' and ' + names[2] + ' like this' # вывод без префикса f
    elif len(names) >= 4:  #
        return f"{names[0]}, {names[1]} and {len(names) - 2} others like this"  # выводим names с индексом 0, names с индексом 1 и
                            # кол-во элементов{len(в списке) - 2} вычитаем 2 из кол-во элементов в списке так как уже указали двоих

print(likes([]))
print(likes(['Peter']))
print(likes(['Jacob', 'Alex']))
print(likes(['Max', 'John', 'Mark']))
print(likes(['Alex', 'Jacob', 'Mark', 'Max']))
print(likes(['Alex', 'Jacob', 'Mark', 'Max', 'Peter', 'Pacob', 'Jacob', 'Mark', 'Max', 'Peter', 'Pacob']))

#from modules import module4_1
##(from)из modules(тут указана папка) (import)импорт файл - здесь импорт всего файла

##(from)из modules(тут указана папка).файл (import)импорт (что импортируем(название функции и тд)) as(как) - принимает название функции/или модуля, когда мы будем к ней обращаться
# from modules.module4_1 import say_hello as sh

##### Пакет — это директория, которая по сути такая же, как и наша "modules".
##### Единственным отличием пакета от обычной папки является наличие внутри файла "__init__.py" с двойным подчеркиванием.
##### Когда мы создали файл "__init__.py", мы заметили, что на изображении нашей папки "modules" появился кружочек.
##### Этот кружочек обозначает, что наш модуль, или наша папка, теперь стала пакетом.

# Существует особенность: когда мы импортируем пакет или взаимодействуем с ним, код из файла "__init__.py" с двойным подчеркиванием
# начинает выполняться. Это происходит аналогично тому, как происходит выполнение кода при импорте какого-либо модуля,
# где вся информация из модуля считывается и выполняется. В случае с файлом "__init__.py" также считывается и выполняется код,
# содержащийся в этом файле.

import modules

print(modules)

# Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
# isdigit = is(является)digit(цифрой) - является цифрой

# CODEWARS 2
# Задача, даются PIN коды разной длины, надо сделать так, чтобы PIN код из 4 или 6 символов выдавало тру
# Остальное False. При этом надо учесть, чтобы True выдавало только когда в наборе цифры.
# Если 4 или 6 символов, но в них есть другие символы кроме цифр, то False
def validate_pin(pin):
    pin = str(pin.lower()) # преобразуем элементы в строку и в нижний регистр
    if "-" in pin or "+" in pin: # если 'символ' в pin(переменной) или если 'символ' в pin(переменной)
        return False # то возвращаем False
    if pin.isdigit() is True: # если pin.isdigit (is-является digit-цифрой) является True
        # Метод .isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
        if len(pin) == 4 or len(pin) == 6: # то если длина(len) pin == 4 или(or) длина(len) pin == 6
            return True # то возвращаем True
        else: # иначе
            return False # возвращаем False
    if pin.isdigit() is False: # если pin.isdigit (is-является digit-цифрой) является False
        return False # возвращаем False

print(validate_pin(22+3))
print(validate_pin(1234123))
print(validate_pin(123456))
print(validate_pin(-123))

#CODEWARS 3 (Почти решил сам)
def to_jaden_case(string):
    # Разбиваем строку на слова и приводим каждое слово к формату с заглавной буквой
    st = ' '.join(word.capitalize() for word in string.split()) # пока не очень разобрался с этими методами.
    return st

result = to_jaden_case("How can mirrors be real if our eyes aren't real")
print(result)

#CODEWAR 4(Не решил)
# Задача, даются элементы, при вводе которых требуется на выходе заменить символы на #, а остальные 4 оставить открытые.
def maskify(cc):
    if len(cc) <= 4:
        return cc
    # Если длина строки больше 4 символов:
    # 1. Вычисляем количество символов, которые нужно заменить на `#`:
    # Это `len(cc) - 4` — длина строки минус 4 символа, которые остаются неизменными.
    # 2. Создаём строку из символов `#` такой длины: `"#" * (len(cc) - 4)`.
    # 3. Берём последние 4 символа строки с помощью среза `cc[-4:]`.
    # 4. Складываем строку из `#` и последние 4 символа, чтобы получить маскированную строку.
    return "#" * (len(cc) - 4) + cc[-4:]

###########
import math

# from math import - если мы возьмем библиотеку «math» и импортируем все из нее, что произойдет с нашим «globals»?
# Обратите внимание, что здесь появилось огромное количество значений.


# ЗДЕСЬ ПРИМЕР ТОГО КАК ФУКНЦИЯ МОЖЕТ СЧИТЫВАТЬ ЗНАЧЕНИЕ ПЕРЕМЕННЫХ ИЗ ГЛОБАЛЬНОГО ПРОСТРАНСТВА
def square(x):
    # global a
# Сейчас «a» находится в другом пространстве имен, а не в глобальном.
    # Она находится в локальном пространстве имен, и с этим можно что-то делать.
    # Однако если мы хотим связать их, например, если мы хотим, чтобы наша функция «square» перезаписывала переменную «a»,
    # которая находится в другом пространстве имен, как это сделать внутри функции? На самом деле это очень просто.
    # Нам нужно добавить оператор «global» и указать, какие значения мы будем использовать из глобального пространства
    d = a ** 2 # По сути, функция обладает своим собственным пространством имен, которое называется локальным, и значение она будет брать из этого локального пространства.
    return d
               # Переменная d находится в локальном пространстве, то есть она существует только в функции
               # Но в глобальном пространстве, мы не можем взять значение из функции, так как оно создается только в функции.
               # Но функция может считывать значения(только чтение) из глобального пространства.

               # Если бы это происходило внутри функции, мы сначала смотрели бы на локальное пространство, потом на глобальное, и
               # только затем на встроенное. Такой порядок называется "изнутри наружу".
               # Таким образом, мы сначала обращаемся к нашему пространству имен, а затем к встроенному пространству имен.
a = 5 # БЕРЕТСЯ ЭТО ЗНАЧЕНИЕ # Переменная находится в глобальном пространстве $$$$$
# Когда мы передаем «a**2», это «a» берется из нашей основной программы.
# То есть, если внутри локального пространства имен ничего нет, мы обращаемся к другому пространству имен — глобальному.
# Этот процесс работает изнутри наружу: мы можем обращаться к глобальным переменным изнутри функции,
# но не можем извлекать значения из функции в нашу программу.

# Мы можем обращаться к глобальным переменным изнутри функции, но не можем извлекать значения из функции в нашу

# Важно не забывать, что у нас в функции есть свое собственное пространство имен.
# Если внутри функции не определено какое-то значение, мы будем пытаться найти его в других местах.
# Если значение определено, мы в первую очередь обращаемся к нему в локальном пространстве.

b = square(2)
print(a)
print(b)
# print(globals()) # Функция globals() возвращает словарь со значениями переменных, представляющий текущую глобальную область видимости модуля

# ПРИМЕР ТОГО КАК ФУНКЦИЯ ИЩЕТ ПЕРЕМЕННЫЕ - Объемлющая область видимости
# from package1.package2.module1 import * - из(from) (папка.папка.модуль) импорт(import) * - звездочка означает импорт всего модуля
d = 4 # нашла бы она ее, если бы ее здесь не было, а вверху у нас был бы импорт модуля
      # то функция начала бы искать d уже в модуле, в модуле она равна 11
def square1(x):
    d = x ** 2
    def even(x):
        nonlocal d # Указываем, что будем перезаписывать переменную d из внешней функции square1
        d = x / 2
        if d % 2 == 0: # в функции even проверка d % 2, она начинает искать значение d изнутри наружу, находит d в функции square1
                       # если бы переменной d не было в функции square1, она бы начала искать в глобальном пространстве
            print('Число четное')
        else:
            print('Число нечетное')
    even(x)
    return d
    # global - Если мы хотим использовать значение из глобального пространства имен в локальном, мы применяем команду «global».

### области видимости - обычно с конца ###
# Встроенная
# Глобальная
# Объемлющая
# Локальная

b = square1(4)
print(b)

def public_function():
    return "I'm a public function."


def _private_function():
    return "I'm a private function."

__all__ = ['public_function']

# В этом примере __all__ — это список, который содержит имена всех объектов, доступных для импорта при использовании
# конструкции from (моймодуль) import *. В данном случае, если где-то в коде написать from (моймодуль) import *,
# будет импортирована только функция public_function, в то время как _private_function останется недоступной.
#
# Таким образом, __all__ определяет интерфейс модуля, который виден при импорте *.
# Это особенно полезно, когда нужно сделать некоторые функции или классы «приватными» или внутренними для модуля,
# чтобы они не могли быть использованы вне его.
#
# Важно отметить, что __all__ влияет только на поведение импорта *.
# Если импортировать объекты напрямую, например, from (моймодуль) import _private_function, то __all__ будет проигнорирован.

#CODEWAR 5
#Просто, учитывая строку слов, верните длину самого короткого слова (слов).
def find_short(s):
    short = len(s) # переменная содержит кол-во символов в аргументе
    for i in s.split(): # цикл i в s.split() в i будет временно помещаться одно слово
        p = len(i) # переменная p содержит в себе кол-во символов в i
        if p < short: # если p меньше short
            short = p # то short равняется p
    return short # возвращаем short

print(find_short('bitcoin take over the world maybe who knows perhaps'))

# DZ 20
def test_function():
    def inner_function():
        print('Я в области видимости функции test_function')
    inner_function()


test_function()


