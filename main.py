print("Hello World") # =str-string строка

print(type(5)) # тип числа =int-integer - целое число
print(type(2.1)) # тип числа =float число с плавающей запятой
print(type("Stro4ka")) # тип данных =str-string строка

# concatenate - связывает, сцепляет, соединяет оператор +, но одинаковые объекты
# запятая в командах "," говорит о том, что элемент закончился и сейчас будет другой

print(78 % 33) # сколько в число 78 помещается число 33 получим остаток от этого/остаток от деления
print(78/33) # деление с плавающей запятой =float
print(78//33) # деление с ответом без запятой =int-integer
print(7 % 7) # сколько в число 7 поместится число 7, если поместилось, то это 0

print(5 ** 3) #степень

#boolean - тип данных "примитивно" да-нет, истина-ложь
print(type(True),type(False))
print(5 == 5, 5 > 2, 3 < 1, 5 != 5, 5 != 4) # == - они равны?, != - они не равны?

'''команда and= и, or= или'''

# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'СТРОГИЙ ОПЕРАТОР'
print(5 == 5 and 5 != 5)
print(10 == 10 and 6 > 3)

# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.
'НЕ СТРОГИЙ ОПЕРАТОР'
print(5 == 5 or 5 != 5)
print(5 > 6 or 6 > 7 )

# Перевод данных в другой тип. Текстовую пятерку перевел в число и также наоборот в строку. Код расшифровывается справа налево.
print(type(int("5")))
print(type(str(5)))

## DZ 1
# 1st program
print(9 ** 0.5 * 5)
# 2nd program
print(9.99 > 99.98 or 1000 != 1000.1)
# 3rd program
print(2 * 2 + 2 == 2 * (2 + 2))
# 4th program
print(int(float ('123.456')* 10 % 10))

# Динамическая типизация - это смена типа данных в переменной
# Оператор = присваивает переменной (прим. Name) тип данных, то есть переменная name ссылается на значение Urban
# Получается, что правый объект присваивает себе некую переменную(левое значение), которую в дальнейшем можно использовать
name1 = 'Urban'
print(name1, type(name1))
name1 = 5
print(name1, type(name1))
name1 = 2.2
print(name1, type(name1))

name01 = 5
name01 = 6
print(name01 + name01) # Запомнит он последний объект привязанный к одной переменной

## DZ 2
name = 'Ilya'
print(name, type(name))
age = 24
print(age,type(age))
age = age + 24
print(age,type(age))
is_student = True
print(is_student, type(is_student))

# Переменная - хранит в себе информацию к которой мы можем обращаться в дальнейшей работе
# Важно, чтобы переменная носила осмысленное название и была эксклюзивной (не была названа другой командой)
# Snake case - название переменной пишется через нижнее подчеркивание (для читаемости и быстрого понимания) - data_of_brith
# Camel case - название переменной пишется с заглавной буквы (каждое слово) - dataOfBrith
## Мне больше понравился стиль snake case, в дальнейшем иногда можно путать ноль и букву О

a, b, c = 1, 2, 3 # Множественное присваивание - присвоить сразу несколько значений в одной строке
print(c + b * a)

a =  b = c = 67 # Каскадное присваивание - то есть a = b = c, а все перечисленные переменные содержат объект int-integer 67
print(a + b + c)

d = list ('Begin') # Преобразование строки в список по символам - (пока не знаю для чего)
print(d)

list1 = [5, 3, 1] # Множественное присваивание со списками (Пока не очень понимаю для чего это)
a, b, c = list1

# DZ 3
completed_dz = 12 # Выполнено заданий
hours_spent = 1.5 # Время на одно задание
name_cource = 'Python' # Название курса
time_one_job = int (completed_dz / hours_spent) # Время на выполнение одного задания

print("Курс:", name_cource,",","Затраченное время на одно задание:", hours_spent,",","Среднее время на выполнения одного задания:", time_one_job, "ч.")

name = "IlyaNefedov"
print('Hello, ' * 2 + name) # Дублирование строки через оператор *

# Индексация строки у каждой строки есть свой порядковый индекс начинается он с нуля
# Так же можно выводить и последнюю букву начиная с -1 (последняя буква), -2 (предпоследняя буква) и так далее.
print(name [0]) # нулевой индекс принимается как первая буква и так далее
print(name [-1]) # индекс со знаком минус выводит буквы с конца
print(name [0:5]) # срез строки последний элемент не выводится, то есть получается 0 - 4 (в данном случае)
print(name [0:8:2]) # 0 начало, 8 конец, 2 шаг # выведет нам с 0 индекса по 8 (не включительно) с шагом 2
# Так же мы можем пропускать начальное и последние значение
print(name [:11]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [:5]) # мы пропустили первое значение, но указали конечное, он сам понял, что не указанное это начало
print(name [0:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [4:]) # мы указали первое, но не указали конечное, поэтому для него конечное это конец строки
print(name [::-1]) # срез с конца строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [::1]) # срез с начала строки с шагом 1, мы не указали начальное и конечно, поэтому эти значения равны началу и концу строки
print(name [-1:-10:-2]) # срез с конца строки, но в начале, до 10 индекса с шагом два, обратный порядок

# DZ 4
example = 'AnString'
print(example [0]) # Первый символ в строке
print(example [-1]) # Последний символ в строке с использованием обратного индекса
print(example [3:]) # Вторая половина строки с нечетным кол-во букв
print(example [::-1]) # Слово наоборот
print(example [::2]) # Каждый второй индекс в строке с использованием шага

##name = input('Введите свое имя: ') # команда input говорит о том, что пользователю нужно ввести данные с клавиатуры
##current_data = 2024 # год на данный момент
##data_of_brith = int (input ('Ваш год рождения: ')) #год рождения юзера, команда int, которая преобразует ВВОД в число
### тк как изначально ВВОДИМЫЕ ДАННЫЕ имеют класс str-string строка
##age = current_data - data_of_brith # год на данный момент минус год рождения юзера
##print ('Добро пожаловать,',name) # выводи приветствия и имя юзера
##print ('В этом году вам исполнилось',age, 'года/лет' ) # выводит строку сколько лет исполнилось юзеру и переменную age
#^^^^ обычная программа, которая считает возраст юзера (без месяца и дня)


print('я строка в нижнем регистре'.replace('строка','человек'))
#заменили слово строка на человек
print('я строка в нижнем регистре'.replace('строка','Человек').replace('я','В').replace(' ','-'))
#замена нескольких слов в строке
print('я строка в нижнем регистре'.replace(' ','.')) #заменили символ ПРОБЕЛ ( ) на символ ТОЧКУ
# команда .upper() - переводит текст в Верхний регистр
# команда .lower() - переводит текст в Нижний регистр
# команда .replace('что заменить','на что заменить') - заменяет выбранное слово на другое

#DZ 5
##my_string = input ('Введите произвольный текст:') #ввод текста в формате данных str
##print('Кол-во символов в строке:',len(my_string)) #команда len подсчитывает кол-во элементов
##print(my_string .upper()) # изменяем текст на верхний регистр
##print(my_string .lower()) # изменяем текст на нижний регистр
##print(my_string .replace(' ', '')) # удалям ПРОБЕЛЫ на ничего
##print(my_string [0:1]) # вывод первого символа в строка
##print(my_string [-1]) # вывод последнего символа в строке
#Здесь должен быть текст посвященный университету урбан

# СПИСКИ
# list_
food = ['apple', 'coco', 'banana', 'cherry', 2] # в квадратных скобках хранятся элементы списка
# то есть у каждого элемента есть порядковый номер он же - индекс
print(food[3]) # нумерация начинается с нуля, как и любой индекс
food [0] = 'beef'# замена нулевого индекса(то есть первого слова) на другое слово
food [2] = 2024 # замена второго индекса(то есть третьего слова) на другой элемент
# списки изменяемые, то есть их можно менять
print(food)

food.append(True) # добавили элемент True
# в списках могут храниться любые типы данных
# добавить в список можно любой тип данных
food.append('pear') #добавили элемент
# метод .appent(что добавить) добавляет элемент в конец списка, можно добавить только один элемент
#food.extend(['True',2,'false'])
food.extend('True')
# метод .extend(что добавить) если добавлять одно слово, то оно разбивается по символам/буквам (каждый отдельно)
food.extend(['True', 2, 'Foll'])
# если добавлять в квадратных скобках(список), то можно сразу несколько разных типов данных
# причина почему она не разбивается на отдельные символы в том, что мы в квадратных скобках уже добавляем последовательность
food.remove('cherry')
# метод .remove # удаление элемента из списка, можно удалить только один элемент

print("beef" in food) # командой in(в) можно проверять если элемент в списке
print('beeed' in food)
# данную команду можно расшифровывать как - если ли "слово (in) в списке?"
print('coco' not in food) # командой not in(не в) можно проверить отсутствие элемента в списке
print('peaar' not in food)
# данную команду можно расшифровывать как - "слово не в списке"?
print(food [-1::-1]) # так же мы можем проводить индексация со списком
print(food)

# tuple - (тайпл) - кортеж - неизменяемый список, может содержать разные типы данных, так же как и список
# тот же самый список, но не изменяемый. нельзя изменить, удалить, добавить
# так же можно хранить в кортеже список
# class "tuple" - кортеж
tuple0 = (1, 2, 3, 4) + (9, 7, 8)
tuple1 = ('string', 'apple', 1, 5, True) # разные типы данных
tuple2 = ('beef', 'classic', ['dream', 'mono', 1, 3]) # так же можно хранить в кортеже список
print(tuple0)
print(tuple1)
print(tuple2)
tuple2[2][0] = 'bag' # в кортеже можно изменять ТОЛЬКО, что уже изменяется - то есть список в квадратных скобках
print(tuple2)
tuple3 = ("dragon",) * 3 # ВАЖНО, если КОРТЕЖ содержит один элемент, то он должен заканчиваться запятой, иначе мы не получим кортеж
# так же можно умножать
print(tuple3)
print(type(tuple3))

# DZ 6
immutable_var = ('string', 'm-track', 'gaming', 1, 2, 3, True, False, ['apple', 'cherry', 'coco'])
print(immutable_var)
immutable_var [8][0] = 'alesis' # кортеж не изменяется, если в нем нет изменяемых данных (к таким относятся типы данных как список)
print(immutable_var)

mutable_list = ['glass', 'long', 'bridge', 1, 5, 10, True]
print(mutable_list)
mutable_list.append('self-mish') # добавили элемент
mutable_list.extend('delete') # добавили элемент по разбиванию на символы
mutable_list.extend(['insert' ,'end']) # если добавлять два элемента команда идентична .append
print(mutable_list)
mutable_list .remove('bridge') # удалили элемент
print(mutable_list)

# Словарь, пара, есть ключ и значение. Изменяемый тип данных .class "dict"
phone_book = {'Ilya':89524460977,'Gaben':30685006988, 'Alina':[89108845077,321], 'Spam':89005558085}
# работает это следующим образом 'КЛЮЧ' : 'ЗНАЧЕНИЕ', 'КЛЮЧ' : 'ЗНАЧЕНИЕ'
# на месте ключа не может быть измененных данных, но в значение может быть и список
print(phone_book)
# если нам нужен элемент, то мы должны с помощью [] указать ключ
# print ('HOMEP:', phone_book['Ilya'])
phone_book['Ilya'] = 89524444444 # мы можем изменять ЗНАЧЕНИЕ обращаясь к ключу
print(phone_book)
phone_book['Misha'] = 89107798734 # если мы обращаемся к несуществующему ключу и пробуем его изменить, он его создает
print(phone_book)
del phone_book['Spam'] # оператор del удаляет данные привязанные к ключу
#оператор del удаляет данные привязанные к ключу
print(phone_book)
phone_book.update( # обновляем список, то есть вводим в него новые данные
    {'Anton' : 89203219876,
     'Vova' :  89556498718}
    )
# метод .update обновляет словарь - вставляет в него новые данные
print(phone_book)
print(phone_book.get('Gaben')) # метод .get позволяется ПОЛУЧИТЬСЯ значение по ключу
print(phone_book.get('Spam')) # метод .get лучше, чем обращение, так как не создает данные, а покажет none - пусто, ничего
print(phone_book.get('Spam', 'Такого ключа не существует'))# так же мы можем поменять значение none на свое через (запятую) после ключа
print(phone_book)
# phone_book.pop('Vova') # так мы удаляем ключ со значением (удаляет один ключ со значением)
# метод .pop удаляет ключ со значением, а если мы укажем переменную, то мы как бы извлечем/перенесем ключ со значением в переменную
delete_phone_book = phone_book.pop('Vova')
print(delete_phone_book)
# list_one = [1,2,3] #,a = list_one.pop(1), print (a) ,print (list_one)# тоже самое можно проделывать со списком
print(phone_book)
print(phone_book.keys()) # метод .keys позволяет получить список ключей
print(phone_book.values()) # метод .keys позволяет получить список значений
print(phone_book.items()) # метод .item позволяет получиться ключ и значение

# Множество class "set"
# Особенность множества в том, что хранит оно только уникальные значения, то есть повторных данных быть не может
set_ = {1, 2, 3, 4, 5, 5, 1, 3, 'StringAll', (1, 2, 3, 4, 9, 1)} # может хранить как числа, так и строки, так и кортеже (при списках выдает ошибку)
# при том что кортеж может хранить в себе повторяющие файлы
set_.discard(1,) # удаление первого элемента (не путать с индексом) удаляет по одному
# метод .discard() удаляет элемент из множества
print(set_)
list_1 = [1, 2, 3, 4, 4, 2, 1] # список
list_1 = set(list_1) # список перевели в множество
print(list_1)
list_1.discard(1) # метод .discard удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то ошибки не будет
list_1.remove(2) # удаление элемента, в скобках указывается сам элемент, если такого элемента нет, то выдаст ошибку
# метод .discard от .remove отличаются тем, что дискард не выдаст ошибку при удалении, если такого элемента не будет
print(list_1)
# метод .pop работает по такому же принципу, что в списках и кортежах
# метод .add добавляет элемент в множество (один элемент)
list_1.add(17)
list_1.add(12)
print(list_1)

# DZ 7
my_dict = {'Ilya':2000, 'Alina':1999, 'Egor':1998} # Словарь с именами и год рождения
print(my_dict)
print(my_dict.get('Egor')) # запрос данных с помощью ключа, метод .get
print(my_dict.get('Misha','Данных нет')) # запрос данных с помощью ключа, метод .get, так как данных нет он выдает none
# но после ключа через запятую можно указать, текст при отсутствии данных
my_dict['Nikita'] = 1987 # если мы обращаемся к несуществующему ключу, то он создает его
my_dict['Artem'] = 1974 # а так мы могли изменить значение по ключу
print(my_dict)
deleted_my_dict = my_dict.pop('Egor') # методом .pop мы можем удалить элемент, но если мы присвоим ему переменную, то значение сохранится в переменную
print(deleted_my_dict) # вывод в консоль удаленного элемента и сохраненного в переменную
del my_dict['Artem'] # оператор del удаляет элемент по ключу
print(my_dict)

my_set = {'beef', 'apple', 1, 2, 4, 5, 6, 2 ,4, 3, 'apple'} # множество состоящие из разных типов данных
print(my_set)
my_set.add('cherry') # метод .add добавляет элемент в множество
my_set.add(10) # метод .add добавляет элемент в множество
print(my_set)
my_set.remove('beef') # метод .remove удаляет элемент в множестве (указать сам элемент)
print(my_set)

# DZ 8
grades = [[5, 3, 3, 5, 4], [2, 2, 2, 3], [4, 5, 5, 2], [4, 4, 3], [5, 5, 5, 4, 5]]
students = {'Johnny', 'Bilbo', 'Steve', 'Khendrik', 'Aaron'}
avg_scores = {} # пустой словарь для среднего балла
names = list(students) # преобразуем множество в список
names.sort() # в алфавитном порядке методом .sort
avg_scores.update(
    {names[0]:sum(grades[0]) / len(grades[0]), names[1]:sum(grades[1]) / len(grades[1])})
avg_scores.update(
    {names[2]:sum(grades[2]) / len(grades[2]), names[3]:sum(grades[3]) / len(grades[3])})
avg_scores.update(
    {names[4]:sum(grades[4]) / len(grades[4])})
# Обновили список следующим образом
# {Имя[Индекс]:Сумма.sum (НазваниеСписка[Индекс]/Кол-во символов.len(НазваниеСписка[Индекс])}
# функция sum сумма чисел
# функция len кол-во символов
print(avg_scores)

# DZ 1 GPT
grades = {
    'Lily': {'math': [4, 3, 5], 'english': [5, 4, 4], 'history': [3, 4]},
    'James': {'math': [5, 5, 4], 'english': [3, 4, 3], 'history': [4, 5]}
}
avg_scores_by_subject = {} # пустой словарь
avg_scores_by_subject.update(
    {"lily":{'math':sum(grades['Lily']['math']) / len(grades['Lily']['math']),
             'english':sum(grades['Lily']['english']) / len(grades['Lily']['english']),
             'history':sum(grades['Lily']['history']) / len(grades['Lily']['history'])}}
)
avg_scores_by_subject.update(
    {"James":{'math':sum(grades['James']['math']) / len(grades['James']['math']),
             'english':sum(grades['James']['english']) / len(grades['James']['english']),
             'history':sum(grades['James']['history']) / len(grades['James']['history'])}}
)

print(avg_scores_by_subject)
print(grades['Lily']['english']) # выводим оценки по предмету 'english' для 'Lily' из словаря grades(слева направо читается код)

# DZ 9
print('Hi,PyCharm and Urban') # вывод текста в консоль
x = 43 # присваиваем переменной х значение 43
y = 32 # присваиваем переменной y значение 43
print(x * y) # вывод в консоль переменной x * y
print('End line') # вывод текста в консоль

name = input('Введите ваше имя: ')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# то выводится строка которая в этом блоке прописана с помощью табуляции
# двоеточие в конце служит для конца условия
# принимает только одно условие
if name == 'Илья':
    print(f'Добро пожаловать юный падаван, {name} ')
# elif это сокращение от else if - иначе если
elif name == 'Алина':
    print(f'Добро пожаловать юный падаван, {name} ')
# else - иначе. Сразу ставится двоеточие
else:
    print(f'Привет, {name}')

number = int(input('Введите число: '))
# if(если) остаток от деления на 3 равен 0, выводим Fizz
if number % 5 == 0  and number % 3 == 0:
    print('FizzBuss')
elif number % 3 == 0:
    print('Fizz')
elif number % 5 == 0:
    print('Buss')
else:
    print('Программе не нравится число')
# if(если) переменная (name) равняется значению 'веденных в кавычках'
# elif это сокращение от else if - иначе если
# else(иначе) сразу ставится двоеточие

'''if — проверяет первое условие.
elif (сокращение от else if) — проверяет следующие условия, если предыдущее условие ложно.
else — выполняет блок кода, если все предыдущие условия ложны.'''

'''Cуществует негласное правило при формировании условий: когда имеются несколько условий, самое маловероятное или самое сложное следует поместить в начало'''
# elif это сокращение от else if - иначе если
'СТРОГИЙ ОПЕРАТОР'
# and= и - если все условия с двух сторон равны, то все выражения считаются истинными
# and= и - чтобы получить «True», должны быть истинны оба выражения
'НЕ СТРОГИЙ ОПЕРАТОР'
# or= или - выражение ложно, если оно с двух сторон ложно, если одно из них истинное, то все выражения истинно
# or= или, чтобы получить «True» достаточно, чтобы истинным было хотя бы одно.

# DZ 10
first = int(input('Введите 3 целых числа: '))
second = int(input('Введите 3 целых числа: '))
third = int(input('Введите 3 целых числа: '))
if first == second == third: # if(если) first равняется second равняется third то выводим 3, то три значения равны
    print(3)
elif first == second or second == third or first == third: # здесь получается надо нам получиться одну истину, чтобы получить значение 2
    print(2)
else: # иначе если не одно число не равно, то получаем ноль
    print(0)

'''Ctrl + Alt + L''' # сборка кода по пеп8

# DZ 2 GPT
a = int(input('Введите одно число: '))
b = int(input('Введите одно число: '))
c = int(input('Введите одно число: '))
d = int(input('Введите одно число: '))
if a == b == c == d:
    print(4)
elif a == b == c or a == b == d or b == c == d or a == c == d:
    print(3)
elif a == b or a == c or a == d or b == c or b == d or c == d:
    print(2)
else:
    print(0)


'''while - до тех пор, пока, это значит, что до тех пор, пока условие, вводимое while, 
истинное, тело цикла продолжит выполняться, при этом количество итераций заранее не известно 
(в отличие от циклов с оператором for).'''

while True:
    number = int(input('Введите число: '))
    if number % 2 == 0:
        print('Число четное')
        break
        # break - завершает выполнение цикла полностью
        # Используется, для выхода из цикла, как только выполнено нужное условие
    else:
        print('Число нечетное')

# continue - пропускает текущую итерацию цикла и переходит к следующей
 # Используется, для перехода к следующей итерации, если выполнено нужное условие

# Пример с тройкой
# GPT Пример работы "continue"
i = 1
while i <= 5:
    if i == 1:
        i += 1  # увеличиваем i перед continue, чтобы избежать зацикливания
        continue  # Пропускаем вывод 1 и переходим к следующей итерации
    print(i)
    i += 1


while True:
    number = int(input('Введите число: '))

# Проверка на отрицательное число
    if number < 0:
        print('Число отрицательное. Введите положительное число.')
        continue # Возвращаемся к началу цикла, чтобы снова запросить ввод

    # Проверка на четность
    if number % 2 == 0:
        print('Число четное')
        break # Завершаем цикл, если число четное
    else:
        print('Число нечетное')

'''# break - завершает выполнение цикла полностью
# Используется, для выхода из цикла, как только выполнено нужное условие

# continue - пропускает текущую итерацию цикла и переходит к следующей
# Используется, для перехода к следующей итерации, если выполнено нужное условие
# Обычно ставится в начале, когда нужно сразу пропустить текущую итерацию цикла, если выполнено определенное условие
# Важно заметить, что continue можно ставить в любом месте цикла, в зависимости от логики программы
# Главное, чтобы оно выполняло свою задачу — пропускать текущую итерацию и переходить к следующей'''

# DZ 10
my_list = [42, 69, 322, 13, 0, 99, -5, 9, 8, 7, -6, 5]
my_list_index = 0 # начальный индекс для списка my_list
while my_list_index < len(my_list): # цикл идет до того момента пока индекс меньше длины списка
    if my_list[my_list_index] < 0: # если элемент списка меньше 0
        break # то цикл заканчивается, тк встретили отрицательно число
    elif my_list[my_list_index] > 0: # иначе если элемент списка больше 0
        print(my_list[my_list_index]) # вывод его в консоль
    my_list_index += 1 # увеличиваем индекс, чтобы перейти к следующему элементу списка
    # Увеличение индекса должно быть вне блоков if или elif, потому что мы хотим, чтобы индекс увеличивался в любом случае после каждого прохода цикла,
    # Независимо от того, выполнилось ли условие в if или elif.

'''В Python квадратные скобки [] — это стандартный синтаксис для индексации (обращения к элементам коллекций). 
Когда ты пишешь my_list[my_list_index], ты говоришь программе: 
"Возьми элемент списка my_list, который находится на позиции, указанной в переменной my_list_index."'''

# DZ GTP 3
numbers = [2, 7, 18, 5, 6, 12, 9, 22, 4, 15, 10]
numbers_index = 0
while numbers_index < len(numbers):
    if numbers[numbers_index] > 20:
        break
    if numbers[numbers_index] == 10:
        numbers_index += 1
        continue
    if numbers[numbers_index] % 2 == 0:
        print(numbers[numbers_index])
    numbers_index += 1
print('123')

# DZ 4 GPT
temps = [16, 22, 20, 14, 26, 18, 9, 23, 15] # температура
temps_index = 0
while temps_index < len(temps):
    if temps[temps_index] < 10:
        break
    if temps[temps_index] == 20:
        temps_index += 1
        continue
    if 15 <= temps[temps_index] <= 25:
        print(temps[temps_index])
    temps_index += 1

# for (название переменной), как правило, ее называют «i», «j» или «k»
# данные переменные будут существовать только в переделе цикла
# for(для)(переменной) in(в) "последовательность"

for i in 1, 2, 3, 4:
    print(i)
list_ = ['hello', 'world', 'party']
for i in list_:
    if i == 'party':
        list_.remove(i)
print(list_)

# range радиус можно указать цифрами, но тогда программа может выдать ошибку если мы не
# знаем сколько элементов, функция len возвращает нам длину элемента, которого мы напишем в скобках
list_ = ['hello', 'world', 'party']
for i in range(len(list_)):
    print(list_[i]) # вывод на экран каждого элемента по отдельности
    list_[i] = 'vince'
    print(list_[i]) # замена каждого элемента на другой

list_2 = [2, 4 ,8, 9, 1, 19]
sum_ = 0
for i in range(len(list_2)):
    sum_ += list_2[i]
print(sum_)

# for i in range(11): # start, end, step - если записать одно число, то оно воспринимается как конец
# функция range конец не включительный
for i in range(1, 11): # start, end, step # i - 1
    for j in range(1, 11): # j - 1
        print(f'{i} x {j} = {i*j}')
# первый цикл с переменной i создается со значением 1
# дальше внутренний цикл с переменной j со значением 1
# пока цикл for с переменной j не дойдет до 10, то цикл for с переменной i не поменяется и так по кругу

dict_ = {'a': 1, 'b': 2, 'c': 3}
for i in dict_:
    print(i, dict_[i])

dict_1 = {'a': 1, 'b': 2, 'c': 3}
for i, k in dict_1.items():
    print(i, k)

# DZ GPT
numbers = [10, 15, 20, 25, 30, 35, 40, 45, 50]
even_numbers = []
odd_numbers = []
for i in range(len(numbers)): # Здесь мы перебираем все индексы списка numbers.
    n = numbers[i] # n — это текущее число из списка `numbers`, с которым мы сейчас работаем
    if n % 2 == 0: #  Если остаток от деления числа `n` на 2 равен 0, то оно четное
        even_numbers.append(n) # Добавляем `n` в список четных чисел
    else: # Иначе, если число не делится на 2 без остатка, оно нечетное
        odd_numbers.append(n) # Добавляем `n` в список нечетных чисел
print('Even', even_numbers)
print('Odd', odd_numbers)

numbers = [3, 10, 15, 18, 20, 21, 25, 30, 33, 35, 40, 45, 50, 60]
divisible_by_3 = []
divisible_by_5 = []
for i in range(len(numbers)):
    n = numbers[i]
    if n % 3 == 0:
        divisible_by_3.append(n)
    if n % 5 == 0:
        divisible_by_5.append(n)
print(divisible_by_3)
print(divisible_by_5)

numbers = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
even_numbers = []
greater_than_ten = []

for k in (numbers):
    # k = numbers[i]
    if k % 2 == 0:
        even_numbers.append(k)
    if k > 10:
        greater_than_ten.append(k)

print(even_numbers)
print(greater_than_ten)

numbers = [23, 45, 12, 67, 89, 34, 54, 23, 90, 123, 78, 56]
odd_numbers = [] # нечетные
even_numbers = [] # четные
for q in numbers:
    if q % 2 == 0:
        even_numbers.append(q)
    else:
        odd_numbers.append(q)
print(odd_numbers)
print(even_numbers)
print(sum(odd_numbers))
print(sum(even_numbers))

numbers = [30, 45, 60, 23, 70, 81, 90, 100, 125, 150, 170, 200]
divisible_by_5 = []
divisible_by_3_and_5 =[]
greater_than_50 =[]
for b in range(len(numbers)):
    z = numbers[b]
    if z % 5 == 0 and z % 3 == 0:
        divisible_by_3_and_5.append(z)
    if z % 5 == 0:
        divisible_by_5.append(z)
    if z > 50:
        greater_than_50.append(z)

print(divisible_by_5)
print(divisible_by_3_and_5)
print(greater_than_50)

numbers = [23, 45, 60, 70, 81, 100, 150, 170, 200, 55, 30, 9, 12]
even_numbers = [] # четные
odd_numbers = [] # нечетные
divisible_by_3_and_5 = []
numbers.sort()
for p in range(len(numbers)):
    u = numbers[p]
    if u % 3 == 0 and u % 5 == 0:
        divisible_by_3_and_5.append(u)
    if u % 2 == 0:
        even_numbers.append(u)
    else:
        odd_numbers.append(u)
print(numbers)
print(even_numbers)
print(odd_numbers)
print(divisible_by_3_and_5)
print(len(even_numbers))
print(len(odd_numbers))
print(sum(divisible_by_3_and_5))

# DZ 11
# Исходный список чисел от 1 до 15
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# Пустые списки для хранения простых и не простых чисел
primes_ = []      # Сюда добавим простые числа
not_primes = []   # Сюда добавим числа, которые не являются простыми

# Основной цикл: перебираем каждое число из списка numbers
for i in range(len(numbers)):
    is_prime = True     # Переменная-флаг: изначально считаем, что число простое
    n = numbers[i]      # Текущее число из списка, которое будем проверять

    # Вложенный цикл: проверяем, есть ли делители у числа n
    # (перебираем делители от 2 до n-1)
    for k in range(2, n):
        if n % k == 0:    # Если n делится на k без остатка, то:
            is_prime = False  # Меняем флаг на False, значит, число не простое
            break            # Прерываем вложенный цикл, так как нашли делитель

    # После проверки числа на простоту добавляем его в соответствующий список
    if is_prime and n > 1:     # Если число простое и больше 1
        primes_.append(n)      # Добавляем его в список простых чисел
    elif n > 1:                # Если число не простое и больше 1
        not_primes.append(n)   # Добавляем его в список не простых чисел

# Выводим списки простых и не простых чисел
print("Primes:", primes_)
print("Not Primes:", not_primes)

# def имя_функции (аргументы):
#     тело_функции
#     return результат
# Здесь:
# имя_функции ― название, с помощью которого можно вызывать функцию в коде;
# аргументы ― значения, которые функция принимает на вход. Это поле может быть пустым;
# тело_функции ― набор инструкций, которые выполняются при вызове;
# результат ― значения, которые функция возвращает при завершении работы.

# def (от англ. define — определить, обозначить)
# То есть, мы как бы определяем функцию. Так же, как и с переменными, по названию функции мы должны понимать ее назначение.
# Рассмотренная ниже функция – это самая простая функция, которую можно встретить - обычная.
# Но функции можно разделить на несколько видов: обычные, принимающие, возвращающие и анонимные.
# Обычная функция
def say_hello():
    print('Hello')

say_hello()

def say_hello(name):
    print('Hello', name)

say_hello(name)

# Принимающая функция
# Поскольку функция принимающая (какое-то значение), у нее есть параметр, в момент вызова функции мы обязательно должны передать этот параметр ей
def say_hello(name): # def - определить say_hello (аргумент)
    print('Hello,', name)

say_hello('Ilya')
say_hello('Alina')
say_hello('Gaben')

import random # библиотека рандом

# Возвращающая функция
# Оператор return используется в функциях для возвращения данных после выполнения работы самой функции.
def lottery(): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win # Возврат win
# После команды return функция прекращает выполнять дальнейшие команды.
# Давайте попробуем вызвать нашу функцию. В ответе ничего не видим.


print(lottery()+lottery())

# Когда мы пишем просто lottery(), функция выполняется, выбирает случайное значение, но затем сразу прекращает работу и возвращает значение,
# которое просто "зависает" в памяти, так как никуда не передано. Если мы хотим увидеть это значение,
# нам нужно вывести его на экран (через print) или сохранить в переменную.
#
# Оба варианта — с print и с присвоением переменной — имеют свои особенности и подойдут для разных ситуаций:
#
# print(lottery()): Этот способ сразу выводит результат на экран, что полезно для быстрой проверки, например, чтобы увидеть результат в консоли.
#
# win = lottery(): Этот вариант сохраняет значение, и мы можем использовать его в дальнейшем коде, повторно к нему обращаться, или, как в примере,
# складывать результаты нескольких запусков функции.

# Но на самом деле возвращающие функции на месте своего вызова оставляют после себя какое-то значение.
# Мы можем поступить так, создать переменную и сохранить в нее вызов функции.
win = lottery() + lottery()
print(win)
print('----')

def lottery(mon, thue): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    return win1, win2 # Возврат win
win1, win2 = lottery('mon', 'thue')
print(win1, win2)
print('----')

# Если мы не знаем сколько параметров будет принимать функция, мы можем написать, например, «*args» для обычных параметров и «**kwargs» для именованных.
def lottery(*args, **kwargs): # определяем лотерея
    tickets = [1, 2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10] # в которой содержится список от 1 до 10 # импорт библиотеки рандом
    win1 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    tickets.remove(win1)
    win2 = random.choice(tickets) # переменная содержащая в себе рандом из списка tickets
    print(*args)
    return win1, win2 # Возврат win
win1, win2 = lottery(1, 2, 3, 4, 5, 6, 7 ,8 ,9 ,10)
print(win1, win2)
print('----')

# Параметры по умолчанию
# Но в случае с нашей функцией нам необязательно передавать параметры, если мы запустим программу, то увидим,
# что компьютер вывел «2» и «True» (Рис.21). Потому что тут были заданы параметры по умолчанию.
def test(a = 2, b = True):
    print(a, b)

test(False, 22)
test([1, 3])
# В ответе мы видим наш список и все то же «True». То есть наш список встал на место параметра «а» и распаковался, как один объект.
# Чтобы распаковать его так, чтобы каждый элемент встал на соответствующее какому-то параметру место, нам нужно поставить звездочку перед списком.
# Чтобы распаковать словарь, нужно поставить две звездочки.
test(*[1, 3])

# DZ 11
def get_matrix(n, m, value): # определяем функцию get_matrix с тремя параметрами
    matrix = [] # создаем пустой список для хранения матрицы
    for i in range(n): # цикл создает n строк в матрице
        matrix.append([]) # добавляем пустой список как новую строку
        for k in range(m): # добавляет m элементов в каждую строку
            matrix[i].append([value]) # вставляем значение value в текущую строку i
    return matrix # возврат данных в список
result1 = get_matrix(2, 2, 10) #
result2 = get_matrix(3, 5, 42) #
result3 = get_matrix(4, 2, 13) #
print(result1)
print(result2)
print(result3)

# DZ 12
# Сначала генерируем случайное число от 3 до 20
one_stone = random.randint(3, 20)
# Печатаем это случайное число, чтобы увидеть, что получилось
print(one_stone)
print('-------')
# Переменная для хранения результата
result = ''
# Два вложенных цикла: первый перебирает все значения от 1 до (one_stone-1),
# второй — от (i+1) до one_stone, чтобы не повторять одинаковые пары
for i in range(1, one_stone - 1):
    for j in range(i + 1, one_stone):  # j начинается с i+1, чтобы не повторять (i, i)
        sum_j_i = i + j  # Считаем сумму текущей пары (i + j)
        # Проверяем, делится ли число one_stone на эту сумму
        if one_stone % sum_j_i == 0:
            result += str(i) + str(j) + ' '  # Если делится, добавляем пару в результат

# Печатаем все найденные пары в строковом виде, убираем лишний пробел в конце
print(result.strip()) # strip(), чтобы удалить пробелы в конце строки

'''Существует несколько видов пространства имен:
Локальное пространство имен
Глобальное пространство имен
Встроенное пространство имен'''

'''Встроенное пространство имен включает в себя имена каких-либо встроенных функций. 
Локальное представляет собой имена, которые мы используем внутри каких-либо функций, которые мы используем и создаем самостоятельно. 
Глобальное пространство имен включает в себя все, что есть в нашей программе, исключая лишь локальное пространство.'''

# Глобальное пространство
z = 5
x = 10

def printer():
    # То что, находится в функции - называется локальным пространством имен
    # Часть, которая находится внутри функции, и является локальным пространством имен
    # Переменные «c» и «d» существуют до тех пор, пока функция не завершит свою работу
    ### Если нам нужно использовать глобальную переменную в функции то пишем global
    global z, x
    c = 110
    d = 220
    z = 'Str'
    x = 'Str 2'
    # В свою очередь есть такая особенность, что к глобальному пространству имен мы можем обращаться напрямую из локального
    # Сделаем для себя пояснение, что «c» и «d» у нас local, а «z» и «x» это global
    print(c, d, 'local')
    print(z, x, 'global')
 # При запуске программы мы видим, что теперь даже после завершения функции используются значения, присвоенные переменным внутри нее.
 # Таким образом во время вызова функции мы переопределили значения переменных «a» и «b» из глобального пространства имен.

printer()
print(z, x)

calls = 0 # переменная со значением 0
def count_call(): # определяем count_call с пустым аргументом
    global calls # используем глобальную переменную, которая сохранена вне функции
    calls += 1 # прибавляем и сохраняем значение в переменную call
    return calls # возвращаем измененное значение в переменную calls
def string_info(string): # определяем string_info с принимающим аргументом
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    tiple1_info_str = (len(string), string.upper(), string.lower()) # создаем кортеж, подсчитываем кол-во элементов в string(принимающем аргументе)
    print(tiple1_info_str) # выводим в консоль кортеж

def is_contains(string, list_to_search): # определяем is_contains с двумя принимающими аргументами
    count_call() # используем функцию count_call для подсчета вызова остальных функция
    string = string.lower() # создаем переменную в которой аргумент переводится в нижний регистр, так как переменные взаимозаменяемые даем такое же название
    new_list_to_search = [z.lower() for z in list_to_search] # Интересная строка. Создаем новый список, в котором элементы из списка list_to_search
                                                             # Преобразуются в нижний регистр
                                                             # Цикл
                                                             # Для каждого элемента в списке list_to_search переменная z временно принимает
                                                             # значение этого элемента, и к нему применяется метод lower(), чтобы привести строку к нижнему регистру.

    if string in new_list_to_search: # если аргумент есть в списке
        print(True) # то выводим в консоль значение True
    else: # иначе
        print(False) # выводим False

string_info('Capybara')
string_info('Armageddon')
is_contains('Urban', ['ban', 'BaNaN', 'urBAN']) # Urban ~ urBAN
is_contains('cycle', ['recycling', 'cyclic']) # No matches
print(calls)